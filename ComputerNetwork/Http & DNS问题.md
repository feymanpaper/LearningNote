## Q1:什么情况下 DNS 会使用 TCP 传输协议？

**区域传送**：
DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。该数据同步传送的量往往比较大且不容有失，该操作没有较高的时效性要求只需要隔段时间定时执行一遍即可。所以**必须采用可靠性高的 TCP 传输协议**。

**数据包过大**：
UDP的DNS协议只要一个请求、一个应答就好了。而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手。但是UDP协议传输内容不能超过512字节。**一般情况下，客户端向DNS服务器查询域名，返回的内容都不超过512字节，用UDP传输即可**。
在最近的几年，DNS服务提供商重新规定了 DNS 应该同时支持 UDP 和 TCP 协议。
DNS 查询由于 DNSSEC 和 IPv6 的引入迅速膨胀，导致 DNS 响应经常超过 MTU 造成数据的分片和丢失，需要依靠更加可靠的 TCP 协议完成数据的传输；
无论是选择 UDP 还是 TCP，最核心的矛盾就在于需要传输的数据包大小，如果数据包小到一定程度，UDP 协议绝对最佳的选择，但是当数据包逐渐增大直到突破 512 字节以及 MTU 1500 字节的限制时，应选择使用更可靠的 TCP 协议来传输 DNS 查询和相应。

## Q2:为什么在http抓包时会抓到状态码为404的响应

所谓`favicon`，即`Favorites Icon`的缩写，是指显示在浏览器收藏夹、地址栏和标签标题前面的个性化图标。 以图标的方式区别不同的网站。
使用浏览器浏览不同站点时，浏览器将自动发送请求。 如果您的浏览器收到有效 favicon.ico 文件，将显示此图标。 如果未收到，则不会显示特殊图标，会报404错误，并且会记录到错误日志中。

## Q3: 为什么第一次http请求得到的状态码为200 ok，第二次http请求得到的状态码为304 not modified？

-   强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互。
-   协商缓存：浏览器发送请求到服务器，服务器判定是否可使用本地缓存。
-   联系与区别：两种缓存方式使用的都是本地缓存；前者无需与服务器交互，后者需要。
![[Pasted image 20230307173139.png]]
#### 强缓存
如图红线所示的过程代表强缓存。用户发起了一个`http`请求后，浏览器发现先本地已有所请求资源的缓存，便开始检查缓存是否过期。有两个http头部字段控制缓存的有效期：`Expires`和`Cache-Control`，浏览器是根据以下两步来判定缓存是否过期的：
1.  查看缓存是否有`Cache-Control`的`s-maxage`或`max-age`指令，若有，则使用响应报文生成时间`Date + s-maxage/max-age`获得过期时间，再与当前时间进行对比（`s-maxage`适用于多用户使用的公共缓存服务器）；
2.  如果没有`Cache-Control`的`s-maxage`或`max-age`指令，则比较`Expires`中的过期时间与当前时间。`Expires`是一个绝对时间。
经过上述两步判断后，若缓存未过期，返回状态码为`200`，则直接从本地读取缓存，这就完成了整个强缓存过程；**如果缓存过期，则进入协商缓存或服务器返回新资源过程**。

#### 协商缓存
当浏览器发现缓存过期后，缓存并不一定不能使用了，因为服务器端的资源可能仍然没有改变，所以需要与服务器协商，让服务器判断本地缓存是否还能使用。此时浏览器会判断缓存中是否有`ETag`或`Last-Modified`字段，如果没有，则发起一个http请求，服务器根据请求返回资源；如果有这两个字段，则在请求头中添加`If-None-Match`字段（有`ETag`字段的话添加）、`If-Modified-Since`字段（有`Last-Modified`字段的话添加）。**注意：**如果同时发送`If-None-Match` 、`If-Modified-Since`字段，服务器只要比较`If-None-Match`和`ETag`的内容是否一致即可；如果内容一致，服务器认为缓存仍然可用，则返回状态码`304`，浏览器直接读取本地缓存，这就完成了协商缓存的过程，也就是图中的蓝线；如果内容不一致，则视情况返回其他状态码，并返回所请求资源。

#### `ETag`和`If-None-Match`
二者的值都是服务器为**每份资源分配的唯一标识字符串**。
-   浏览器请求资源，服务器会在响应报文头中加入`ETag`字段。资源更新时，服务器端的`ETag`值也随之更新；
-   浏览器再次请求资源时，会在请求报文头中添加`If-None-Match`字段，它的值就是上次响应报文中的`ETag`的值；
-   服务器会比对`ETag`与`If-None-Match`的值是否一致，如果不一致，服务器则接受请求，返回更新后的资源；如果一致，表明资源未更新，则返回状态码为`304`的响应，可继续使用本地缓存，要注意的是，此时响应头会加上`ETag`字段，即使它没有变化

#### `Last-Modified`和`If-Modified-Since`
二者的值都是GMT格式的时间字符串。
-   浏览器第一次向服务器请求资源后，服务器会在响应头中加上`Last-Modified`字段，表明该资源最后一次的修改时间；
-   浏览器再次请求该资源时，会在请求报文头中添加`If-Modified-Since`字段，它的值就是上次服务器响应报文中的`Last-Modified`的值；
-   服务器会比对`Last-Modified`与`If-Modified-Since`的值是否一致，如果不一致，服务器则接受请求，返回更新后的资源；如果一致，表明资源未更新，则返回状态码为`304`的响应，可继续使用本地缓存，与`ETag`不同的是：此时响应头中不会再添加`Last-Modified`字段。

#### `ETag`较之`Last-Modified`的优势
你可能会觉得使用`Last-Modified`已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要`ETag`呢？`HTTP1.1`中`ETag`的出现主要是为了解决几个`Last-Modified`比较难解决的问题：
-   一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新`GET`；
-   某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，`If-Modified-Since`能检查到的粒度是s级的，这种修改无法判断(或者说`UNIX`记录`MTIME`只能精确到秒)；
-   某些服务器不能精确的得到文件的最后修改时间。
这时，利用`ETag`能够更加准确的控制缓存，因为`ETag`是服务器自动生成的资源在服务器端的唯一标识符，资源每次变动，都会生成新的`ETag`值。`Last-Modified`与`ETag`是可以一起使用的，但服务器会优先验证`ETag`。

## Q4：每一次发送http请求得到的状态码均为304，如何解决？

首先需要理解Q3中为什么第一次http请求得到的状态码为200 ok，第二次http请求得到的状态码为304 not modified。要解决每一次发送http请求得到的状态码均为304的问题，需要清除本地缓存，具体而言，需要 清除发送请求所使用的浏览器中的缓存文件。
以Chrome浏览器为例：
点开设置----->隐私和安全性------>清除浏览数据(把缓存文件勾选上)

## Q5：关于DNS抓包实验中的问题4 DNS查询请求的Type

常见查询类型Qtype如下：
![[qtype.png]]
在我们抓包的过程当中，我们主要关注type为A的dns报文，代表着查询目标服务器的ipv4地址，如图所示，在抓包界面，dns查询报文，dns回复报文的相应位置均能看到查询类型Qtype
![[A985CC17-310D-4FC1-B448-E5FDE861AB25.png]]
![[dns请求报文.png]]
![[dns回复报文.png]]

## Q5：为什么DNS查询过程中只能抓到本机和Local DNS服务器的数据包，而抓不到根DNS服务器的？

如下图：本机在查询某一个Web服务器的ip地址时，会首先查本地的dns缓存，如果找不到，再向Local DNS服务器（一般是网络运营商分配的，最近的DNS服务器）查询。此后Local DNS服务器会先查Local DNS服务器本地缓存，如果查不到会代替本机去向根域名服务器及其他权威域名服务器查询ip（**注意是Local DNS代替本机向其他DNS服务器查询目标服务器的ip**）。**而wireshark只是抓本机某一个网卡的网络流量，因此只能看到本机和Local DNS的通信过程，而抓不到Local DNS和其他域名服务器通信的过程。**
![[Pasted image 20230307221117.png]]

对Local DNS迭代查询其他域名服务器感兴趣的同学可以了解`dig`命令，效果如下
```bash
dig www.baidu.com ++trace
```

![[Pasted image 20230307222001.png]]

## Q6: 关于DNS抓包实验中的问题7 
这个网页包含一些图片。在获取每个图片前，您的主机是否都发出了新的 DNS 查询？为什么？

由于每条http请求消息中只能写 1 个 URI，所以每次只能获取 1 个文件，如果需要获取多个文件，必须对每个文件单独发送 1 条请求。比如 1 个网页中包含 3 张图片，那么获取网页加上获取图片，一共需要向 Web 服务器发送 4 条请求。
这个实验所对应的网址 https://www.ietf.org/ 存在许多资源文件，但由于其采用了更加安全的https协议（在HTTP的基础上加了SSL/TLS层（安全套接层）的安全的超文本传输协议，其传输的内容是通过加密得到的，所以说是一种安全的传输），因此我们较难用wireshark抓到本机与目标服务器之间的http通信过程。
但我们可以用wireshark抓到本机查询Local DNS的过程。在下图中，我们发现本机向Local DNS发起了两次type为A的DNS查询，得到了两个目标域名的ip地址。
但网址 https://www.ietf.org/ 存在的资源文件是不止两个的，且在短时间内再次访问该网址也没有产生新的dns查询。因此可以认为本机请求之后进行了本地缓存，不会对每个资源的请求都发起新的DNS查询。
![[Pasted image 20230308113306.png]]
如下图，DNS回复报文中的Answers条目中的time to live字段是缓存过期时间，在缓存过期后发起请求，会产生新的DNS查询。此外，也可以主动清除本地缓存。
![[Pasted image 20230308115550.png]]

## Q7：Session, Cookie, Token
https://www.bilibili.com/video/BV1ob4y1Y7Ep/?spm_id_from=333.337.search-card.all.click&vd_source=108d23f95683578313bdaf5d938b5b3d
http是无状态的
要实现登陆之后不需要再输入账号和密码
Session是诞生且保存在服务器
Cookie是数据载体，把Session放入Cookie送到客户端，Cookie跟随每次http请求发送
Token是诞生在服务器，保存在浏览器，可以放在Storage或者Cookie里面

随着互联网用户群体的发展，如果依旧使用基于Cookie的Session，服务器可能会面临需要存储大量的Session ID在服务器，如果存在多台服务器，服务器之间还需要分享数据

随后出现了JWT（Json Web Token）
JWT：Json Web Token, 通过数字签名的方式，以Json对象为载体，在不同服务终端之间安全地传输信息
JWT用法：最常见的场景是授权认证，一旦用户登陆，后续的每个请求都将包含JWT，系统在每次处理用户的请求之前，都要先进行JWT安全校验，通过之后再进行处理
JWT由三个部分组成，用`.`拼接，三部分分别是Header, Payload, Signature
Header和Payload会分别进行base64编码，服务器保存的密码，三部分加密得到签名信息

服务器只需要保存JWT签名的密文，客户端每次可把JWT放在Cookie或者Storage中，发起http请求



### URI 格式
![[AndroidNote/img/URI格式.png]]

-   协议（protocol）：采用的协议方案；协议确定如何传输请求。我们主要是处理http和https。其他常见的协议还有file和ftp。
-   登录信息（username & password）：（可选项）指定用户名和密码，用来从服务器获取资源时的认证信息；
-   服务器地址（hostname）：待访问的服务器地址。可以是域名形式也可以是 IP 地址；
-   服务器端口号（port）：指定服务器连接网路的端口号；
-   带层次的文件路径（pathname）：指定服务器上的文件路径来定位特指的资源；
-   查询字符串（search）：（可选项）查询字符串参数；
-   片段标识符（hash）：（可选项）用来标记已获取资源中的子资源；

Url example：
https://google.com/#q=express
http://www.bing.com/search?q=grunt&first=9
http://localhost:3000/about?test=1#history

主机名/域名：主机名标识服务器。（例如163.com想建立一个www服务器，[所以就有www.163.com](http://xn--www-vs9dy12d3ricvi.163.com/)，想建立一个邮箱服务器，mail.163.com就有了），另外，也许还会有子域名作为主机名的前缀。子域名可以是任何形式的，其中www最为常见。子域名通常是可选的。

域名/子域名/主机名：

.com是顶级域名，baidu.com是一级域名。
www.baidu.com、bbs.baidu.com、news.baidu.com是二级域名。
ibm.com是域名，域名下可以有多个主机，域名下还可以有多个子域名，例如server1.ibm.com、server2.ibm.com、www.ibm.com。

URI 和 URL 之间的主要区别在于 URI 是标识符，而 URL 是定位器。换句话说，URI 只是标识资源。它不描述或暗示如何定位资源。换言之，URL 是指定位置的 URI，而 URI 同时指定名称和位置的。URL 是 URI 的特定子集。这意味着，所有 URL 都是 URI，但并非所有 URI 都是 URL。

