## Introduction
Three critical randomness rules: 
Rule 1 – Do not use a static OTP value; 
Rule 2 – Do not generate OTP values according to specific patterns; 
Rule 3 – Do not use a constant or predictable seed to initialize a randomness function.
If the OTP values generated for user authentication violate any of the randomness rules, those OTP values can be predicted, and thus the authentication scheme can eventually be cracked.

## Challenge 

PRNGs are typically implemented on the server-side, and thus the source code is not accessible.

A major challenge in the vulnerability analysis of OTP values is to determine which algorithm and function are used to generate PRNs and which parameters they are given as input. To address this challenge, we collected PRNG sample codes written in diverse programming languages shared by app developers on GitHub [17] and Stack Overflow [18] to learn the popular approaches for implementing PRNGs.

1)How to determine the randomness algorithm and the PRNG implementation resided on the server-side?
2)How many OTP values should be gathered to infer potential patterns in an OTP sequence?
3)How can we collect OTP values for our experiments without affecting the OTP server?


## Motivation
however, these studies seldom analyze PRNG implementations in apps. The techniques proposed for assessing the PRNG implementations mainly focus on open-source systems (e.g., Linux [8], OpenSSL [9]). However, these techniques rely on code analysis and thus cannot be applied to analyze PRNGs of Android apps. This paper focuses on the following two goals: 1) exploring security vulnerabilities in SMS OTP values generated by Android apps; 2) gaining insights into potential implementation issues of PRNGs used by these vulnerable apps, without accessing the source code of the PRNGs.

## Implementation
Through reverse engineering, OTP-Lint identifies the apps using SMS OTP and triggers each app’s login functionality to retrieve OTP values.

OTP-Lint first identifies the login Activity declared in each app using a fuzzing-inspired approach. It then recognizes those apps which use SMS OTP authentication through keyword matching. By locating the OTP login widgets, OTP-Lint triggers the relevant app functionalities and sends OTP requests to the app server to retrieve OTP values. Finally, OTP-Lint evaluates whether the gathered OTP values violate any of the three introduced randomness rules.

Authentication Locator：
The variety of login Activities, which are named differently, makes it challenging to identify login Activities by simply using keywords matching