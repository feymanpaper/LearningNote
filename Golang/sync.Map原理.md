https://mp.weixin.qq.com/s/nMuCMA8ONnhs1lsTVMcNgA

sync.Map的readmap没有加锁，而是通过for循环+原子操作的方式来保证并发修改安全。锁是保证同一时刻只有一个goroutine访问临界资源, for+原子操作是保证最后总有一个goroutine完成最后的修改，但是至于谁是最后一个，这是gmp模型进行调度的。总而言之，无论是锁还是for循环+原子操作，都保证了goroutine对临界资源的修改具有先后顺序(但至于谁先谁后是gmp调度决定的),而不是同时(同时会产生并发问题), 而如果大家有需求需要指定A先访问临界区，B再访问临界区，这就是goroutine同步的内容了, 可以了解下sync.waitgroup

### **原子操作与互斥锁的区别**
互斥锁是一种数据结构，使你可以执行一系列互斥操作。而原子操作是互斥的单个操作，这意味着没有其他线程可以打断它。那么就`Go`语言里`atomic`包里的原子操作和`sync`包提供的同步锁有什么不同呢？

首先`atomic`操作的优势是更轻量，比如`CAS`可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作。这可以大大的减少同步对程序性能的损耗。

原子操作也有劣势。还是以`CAS`操作为例，使用`CAS`操作的做法趋于乐观，总是假设被操作值未曾被改变（即与旧值相等），并一旦确认这个假设的真实性就立即进行值替换，那么**在被操作值被频繁变更的情况下，**`**CAS**`**操作并不那么容易成功。**而使用互斥锁的做法则趋于悲观，我们总假设会有并发的操作要修改被操作的值，并使用锁将相关操作放入临界区中加以保护。

所以总结下来原子操作与互斥锁的区别有：

- 互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作。
- 原子操作是针对某个值的单个互斥操作。
- 可以把互斥锁理解为悲观锁，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程