https://mp.weixin.qq.com/s/KYiZvFRX0CddJVCwyfkLfQ
### CAP理论通俗解释:
一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区。
当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。
提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里。容忍性就提高了。
然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。
总的来说就是，数据存在的节点越多，分区容忍性越高，但要复制更新的数据就越多，一致性就越难保证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低

### redis和etcd分布式锁
基于 Golang 实现主动轮询(redis)和 watch 回调(etcd, zookeeper)两种模式的分布式锁. 本文分别以redis 和 etcd 两个组件为例进行了分布式锁的原理介绍及源码展示.
redis 可以算是我们最常用于实现分布式锁的组件，但是由于其中缺少续约机制以及存在数据弱一致性的问题，导致分布式锁的独占性并不能够得到保证. （redis保证了AP）
etcd基于lease租约机制(和redisson的watch dog机制类似)解决分布式锁的独占性问题，基于 revision 机制的协调下，根据取锁序号（revision）的先后顺序排成一条队列，每当锁被释放，只会惊动到下一顺位的取锁方，解决惊群问题. (etcd, zookeeper保证了CP)

