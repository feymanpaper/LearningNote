MySQL索引原理及慢查询优化
https://tech.meituan.com/2014/06/30/mysql-index.html
select count详解
https://juejin.cn/post/6864874941288972296
### 一条SELECT语句是如何执行的
https://xiaolincoding.com/mysql/base/how_select.html#mysql-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84
![](Pasted%20image%2020240103090816.png)
执行一条 SQL 查询语句，期间发生了什么？
- 连接器：建立连接，管理连接、校验用户身份；
- 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
- 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
- 执行 SQL：执行 SQL 共有三个阶段：
    - 预处理阶段：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列。
    - 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
    - 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；


可以看到， MySQL 的架构共分为两层：**Server 层和存储引擎层**，
- **Server 层负责建立连接、分析和执行 SQL**。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。
- **存储引擎层负责数据的存储和提取**。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。

索引下推
能够减少**二级索引**在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。
可以看到，使用了索引下推后，虽然 reward 列无法使用到联合索引，但是因为它包含在联合索引（age，reward）里，所以直接在存储引擎过滤出满足 reward = 100000 的记录后，才去执行回表操作获取整个记录。相比于没有使用索引下推，节省了很多回表操作。

当你发现执行计划里的 Extr 部分显示了 “Using index condition”，说明使用了索引下推


https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&mid=2247484069&idx=1&sn=d40d90ab9e3041757262be5192a46e9e&chksm=e981e10bdef6681dde2ede9c1293e4b379fb827ab3c7d64ae828311c4ee14e19e20d7537d5f0&scene=178&cur_album_id=2241646955158355975#rd
![](Pasted%20image%2020240102150910.png)
1. 处理连接，本质上是进程间通信的过程(TCP/IP，也可以采用管道和共享内存的方式); 默认最大连接数为151。默认8小时自动断开连接
4. 查询缓存(默认关闭, 8.0之后移除了缓存功能)
5. 解析器 (词法分析，语法分析)
6. 预处理器(解决解析器无法解析的语义, 如检查表和列名是否存在)
7. 查询优化器(根据解析树生成不同的执行计划（Execution Plan），然后选择一种最优的执行计划，MySQL 里面使用的是基于开销（cost）的优化器，哪种执行计划开销最小，就用哪种，比如1. 当我们对多张表进行关联查询的时候，以哪个表的数据作为基准表。2. 有多个索引可以使用的时候，选择哪个索引。)
8. 执行计划
9. 存储引擎
在创建表的时候可以指定当前表的存储引擎，如果没有指定，默认的存储引擎为InnoDB，如果想显式指定存储引擎，可以这样
```mysql
CREATE TABLE `t_user_innodb` (  
  `id` int(11) NOT NULL AUTO_INCREMENT,  
  PRIMARY KEY (`id`)  
) ENGINE=innodb DEFAULT CHARSET=utf8mb4;
```

**MylSAM**
应用范围比较小，表级锁定限制了读/写的性能，因此在Web和数据仓库配置中，通常用于只读或以读为主的工作。
特点:
- 支持表级别的锁（插入和更新会锁表），不支持事务
- 拥有较高的插入（insert）和查询（select）速度
- 存储了表的行数（count速度更快）
```
怎么快速向数据库插入100万条数据？
可以先用MylSAM插入数据，然后修改存储引擎为InnoDB。
```

**InnoDB**
MySQL 5.7及更新版中的默认存储引擎。InnoDB是一个事务安全（与ACID兼容）的MySQL 存储引擎，它具有提交、回滚和崩溃恢复功能来保护用户数据。InnoDB行级锁（不升级为更粗粒度的锁）和Oracle风格的一致非锁读提高了多用户并发性。InnoDB将用户数据存储在聚集索引中，以减少基于主键的常见查询的I/O。为了保持数据完整性，InnoDB还支持外键引用完整性约束。

特点：
- 支持事务，支持外键，因此数据的完整性、一致性更高；
- 支持行级别的锁和表级别的锁；
- 支持读写并发，写不阻塞读（MVCC）；
- 特殊的索引存放方式，可以减少IO，提升査询效率。

**Memory**
将所有数据存储在RAM中，以便快速访问。这个引擎以前被称为堆引擎。
特点: 
- 把数据放在内存里面，读写的速度很快，但是数据库重启或者崩溃，数据会全部消失；
- 只适合做临时表。

如何选择存储引擎
- 如果对数据一致性要求比较高，需要事务支持，可以选择InnoDB。
- 如果数据查询多更新少，对查询性能要求比较高，可以选择MyISAM。
- 如果需要一个用于查询的临时表，可以选择Memory。

### MySQL 一行记录是怎么存储的？
https://xiaolincoding.com/mysql/base/row_format.html
#### 表空间结构是什么样的？
**表空间由段（segment）、区（extent）、页（page）、行（row）组成**

行row
数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。
后面我们详细介绍 InnoDB 存储引擎的行格式，也是本文重点介绍的内容

页page
记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。
因此，**InnoDB 的数据是按「页」为单位来读写的**，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。
**默认每个页的大小为 16KB**，也就是最多能保证 16KB 的连续存储空间。
页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。
总之知道表中的记录存储在「数据页」里面就行。

区extent
我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。
B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。
解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。
那具体怎么解决呢？
**在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了**

段 segment
表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。
- 索引段：存放 B + 树的非叶子节点的区的集合；
- 数据段：存放 B + 树的叶子节点的区的集合；
- 回滚段：存放的是回滚数据的区的集合，之前讲[事务隔离 (opens new window)](https://xiaolincoding.com/mysql/transaction/mvcc.html)的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。

#### COMPACT 行格式长什么样？
![](Pasted%20image%2020240103100654.png)
一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分

##### 记录的额外信息
记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。

变长字段长度列表
这些变长字段的真实数据占用的字节数会按照列的顺序**逆序存放**
**NULL 是不会存放在行格式中记录的真实数据部分里的**,所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。

```
为什么「变长字段长度列表」的信息要按照逆序存放？

这个设计是有想法的，主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以**使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率**。
同样的道理， NULL 值列表的信息也需要逆序存放。
```

```
每个数据库表的行格式都有「变长字段字节数列表」吗？

其实变长字段字节数列表不是必须的。
**当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了**，因为没必要，不如去掉以节省空间。
所以「变长字段长度列表」只出现在数据表有变长字段的时候
```

NULL 值列表
表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。
如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。
- 二进制位的值为`1`时，代表该列的值为NULL。
- 二进制位的值为`0`时，代表该列的值不为NULL。
另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 `0`。

```
每个数据库表的行格式都有「NULL 值列表」吗？

NULL 值列表也不是必须的。
**当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了**。
所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。
```

```
「NULL 值列表」是固定 1 字节空间吗？如果这样的话，一条记录有 9 个字段值都是 NULL，这时候怎么表示？

「NULL 值列表」的空间不是固定 1 字节的。
当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推。
```

记录头信息
记录头信息中包含的内容很多，我就不一一列举了，这里说几个比较重要的：
- delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。
- next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
- record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录

##### 记录的真实数据
- row_id
如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。
- trx_id
事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。
- roll_pointer
这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。

#### 练习题
```
varchar(n) 中 n 最大取值为多少？

我们要清楚一点，**MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节**。
也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，注意是一行的总长度，不是一列。

一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。
```

```
> MySQL 怎么知道 varchar(n) 实际占用数据的大小？

MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。
```

```
> MySQL 的 NULL 值是怎么存放的？

MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。
NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。
```

```
> 行溢出后，MySQL 是怎么处理的？

MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 `16KB`，也就是 `16384字节`，而一个 varchar(n) 类型的列最多可以存储 `65532字节`，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会**发生行溢出，多的数据就会存到另外的「溢出页」中**

Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。
Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。
```

### 一条SQL更新语句是如何执行的
https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&mid=2247484093&idx=1&sn=f0fb512d536701c3e0ecdbf330fd6f9d&chksm=e981e113def668058493e9102039b45034312946326fca9906744615b4547a364aa7bc445c16&scene=178&cur_album_id=2241646955158355975#rd
![](Pasted%20image%2020240102155656.png)
1. 客户端发送更新命令到MySQL服务器，经过处理连接、解析优化等步骤；
2. Server层向InnoDB存储引擎要id=1的这条记录；
3. 事务开始, 存储引擎先从缓存中查找这条记录，有的话直接返回，没有则从磁盘加载到缓存中然后返回；
4. Server层执行器修改这条记录的name字段值；
5. 存储引擎更新修改到内存中；
6. 存储引擎记录redo日志，并将状态设置为`prepare`状态；
7. 记录redo log
8. 存储引擎通知执行器，修改完毕，可以进行事务提交；
9. Server先写了个binlog；
10. Server提交事务；
11. 存储引擎将redo日志中和当前事务相关的记录状态设置为`commit`状态。

背景知识: 
#### 什么是InnoDB页？Buffer Pool是什么？为什么这么设计？
InnoDB页
InnoDB存储引擎将数据划分为若干个页，以页作为磁盘和内存之间交互的最小单位。InnoDB中页的大小默认为16KB。也就是默认情况下，一次最少从磁盘中读取16KB的数据到内存中，一次最少把内存中16KB的内容刷新到磁盘上。

缓冲池Buffer Pool
为了缓存磁盘的页，InnoDB在MySQL服务器启动时会向操作系统申请一片连续的内存区域，这片内存区域就是**Buffer Pool**
很容易理解，为了更好地缓存页数据，Buffer Pool对应的一片连续内存空间也被划分为若干个页，而且默认情况下，Buffer Pool页的大小和InnoDB页大小一样，都是16KB。为了区分两种不同的页，我们将Buffer Pool中的页面称为缓冲页

读取数据的时候，InnoDB先判断数据是否在Buffer Pool中，如果是，则直接读取数据进行操作，不用再次从磁盘加载；如果不是，则从磁盘加载到Buffer Pool中，然后读取数据进行操作。
修改数据的时候，也是将数据先写到Buffer Pool缓冲页中，而不是每次更新操作都直接写入磁盘。当缓冲页中的数据和磁盘文件不一致的时候，缓冲页被称为脏页。

那么脏页是什么时候被同步到磁盘呢？
InnoDB中有专门的后台线程每隔一段时间会把脏页的多个修改刷新到磁盘上，这个动作叫做「刷脏」
#### 什么是表空间？不同存储引擎的表在文件系统的底层表示上有什么区别？
表空间
为了更好地管理页，MySQL又设计了「表空间」的概念。表空间又有很多类型，具体类型我们不需要知道，我们只需要知道，一个表空间可以划分成很多个InnoDB页，InnoDB表数据都存储在某个表空间的页中。
为了方便我们定位，MySQL贴心地为表空间设计了一个唯一标识——表空间ID（space ID）。同理，InnoDB页也有自己的唯一编号——页号（page number）。
因此，我们可以这么认为。给定表空间ID和页号以及页的偏移量，我们就可以定位到InnoDB页的某条记录，也就是数据库表的某条记录。

InnoDB是如何存储表数据的
「表空间」是InnoDB存储引擎独有的概念。
我们看到`t_user_innodb`表在数据库对应的`test`目录下会生成以下两个文件
- t_user_innodb.frm
- t_user_innodb.ibd
其中，t_user_innodb.ibd就是`t_user_innodb`表对应的表空间在文件系统上的表示；t_user_innodb.frm用来描述表的结构，如表有哪些列，列的类型是什么等。

MyISAM是如何存储表数据的
和InnoDB不同，MyISAM没有表空间的概念，表的数据和索引全都直接存放在对应的数据库子目录下，可以看到`t_user_myisam`对应了三个文件
- t_user_myisam.MYD
- t_user_myisam.MYI
- t_user_myisam.frm
其中，t_user_myisam.MYD表示表的数据文件，也就是我们实际看到的数据表的内容；t_user_myisam.MYI表示表的索引文件，为该表创建的索引都会存放在这个文件中；t_user_myisam.frm用来描述表的结构。

MEMORY是如何存储表数据的
MEMORY存储引擎对应的数据表只有一个描述表结构的文件t_user_memory.frm
#### MySQL的三种日志文件redo日志、undo日志、binlog分别是什么？为什么需要这么多种类型的日志？
##### redo日志(数据恢复)
InnoDB中有专门的后台线程每隔一段时间会把脏页的多个修改刷新到磁盘上，这个动作叫做「刷脏」
不定时刷脏又带来一个问题。如果脏页的数据还没有刷新到磁盘上，此时数据库突然宕机或重启，这些数据就会丢失。

首先想到的最简单粗暴的解决方案就是在事务提交之前，把该事务修改的所有页面都刷新到磁盘。但是上文说过，页是内存和磁盘交互的最小单位，如果只修改了1个字节，却要刷新16KB的数据到磁盘上，不得不说太浪费了，此路不通！

所以，必须要有一个持久化的措施。
为了解决这个问题，InnoDB把对所有页的更新操作（再强调一遍，包含INSERT、UPDATE、DELETE）专门写入一个日志文件。
当有未同步到磁盘中的数据时，数据库在启动的时候，会根据这个日志文件进行数据恢复。我们常说的关系型数据库的`ACID`特性中的`D`（持久性），就是通过这个日志来实现的。
这个日志文件就是大名鼎鼎的**redo日志**。

```
这就出现了一个有意思的问题，刷新磁盘和写redo日志都是进行磁盘操作，为什么不直接把数据刷新到磁盘中呢？

因为刷脏是随机I/O，而记录日志是顺序I/O（连续写的），顺序I/O效率更高，本质上是数据集中存储和分散存储的区别。因此先把修改写入日志文件，在保证了内存数据的安全性的情况下，可以延迟刷盘时机，进而提升系统吞吐。
```
redo日志位于MySQL数据目录下，默认有`ib_logfile0`和`ib_logfile1`两个文件
可以发现，两个redo日志文件的大小都是50331648，默认48MB。为什么这个大小是固定的呢？因为如果我们要使用顺序I/O，就必须在申请磁盘空间的时候一次性决定申请的空间大小，这样才能保证申请的磁盘空间在地址上的连续性。
这也就决定了redo日志的旧数据会被覆盖，一旦文件被写满，就会触发Buffer Pool脏页到磁盘的同步，以腾出额外空间记录后面的修改。

##### undo日志(事务回滚)
undo log（撤销日志或回滚日志）记录了事务发生之前的数据状态，分为insert undo log和update undo log。
如果修改数据时出现异常，可以用 undo log来实现回滚操作（保持原子性）。可以理解为undo日志记录的是反向的操作，比如INSERT操作会记录DELETE，UPDATE会记录UPDATE之前的值，和redo日志记录在哪个物理页面做了什么操作不同，所以这是一种逻辑格式的日志。
undo日志和redo日志与事务密切相关，被统称为「事务日志」。
##### binlog日志
从MySQL整体架构来看，其实可以分成两部分
- Server 层，它主要做的是 MySQL功能层面的事情，比如处理连接、解析优化等；
- 存储引擎层，负责存储相关的具体事宜。
redo日志是InnoDB存储引擎特有的日志，而Server层也有自己的日志，称为 binlog（归档日志），它可以被所有存储引擎使用
```
为什么有了redo日志还需要 binlog？

我想你可能会问出这个问题，实际上，更准确的问法是为什么有了binlog还需要有redo日志？主要有以下几个原因。
1. binlog日志是用来归档的，binlog以事件的形式记录了所有的 DDL和 DML 语句（因为它记录的是操作而不是 数据值，属于逻辑日志），但是不具备宕机恢复的功能，因为可能没有来得及刷新脏页，造成脏页数据的丢失，而这些操作也没有保存到binlog中从而造成数据丢失；
2. 因为最开始MySQL里并没有InnoDB存储引擎。MySQL自带的引擎是MyISAM，但是 MyISAM没有崩溃恢复的能力，InnoDB后来以插件的形式被引入，顺便带来了redo日志；
3. binlog记录的是关于一个事务的具体操作内容，即该日志是逻辑日志。而redo日志记录的是关于每个页的更改的物理情况。功能压根不是一回事儿。
```

binlog日志的作用-主从复制
binlog是实现MySQL主从复制功能的核心组件。
master节点会将所有的写操作记录到binlog中，slave节点会有专门的I/O线程读取master节点的binlog，将写操作同步到当前所在的slave节点
![](Pasted%20image%2020240102160654.png)
```
假如这条更新语句已经被写入到了redo日志，还没来得及写binlog的时候，MySQL宕机重启了，我们看一下会发生什么?
```
因为redo日志可以在重启的时候用于恢复数据，所以写入磁盘的是chanmufeng1994。但是binlog里面没有记录这个逻辑日志，所以这时候用binlog去恢复数据或者同步到从库，就会出现数据不一致的情况。
所以在写两个日志的情况下，就类似于「分布式事务」的情况，如果你不清楚分布式事务是个什么东西也没关系，我在之后的文章会介绍到。能够明确的就是redo日志和binlog日志如果单纯依次进行提交是无法保证两种日志都写成功或者都写失败的。

我们需要「两阶段提交」。

```
两阶段提交不是MySQL的专利，两阶段提交是一种跨系统维持数据逻辑一致性的常见方案，尤其在分布式事务上，所以请读者重点体会思想
```

我们把redo日志的提交分成两步，两步中redo日志的状态分别是`prepare`和`commit`。步骤如下
1. InnoDB存储引擎将更改更新到内存中后，同时将这个更新操作记录到redo日志里面，此时redo日志处于`prepare`状态；
2. 执行器生成这个操作的binlog，并将binlog刷盘；
3. 执行器调用InnoDB的提交事务接口，InnoDB把刚刚写入的redo日志改成`commit`状态。至此，所有操作完成。

### 为什么MySQL的主键查询这么快
https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&mid=2247484235&idx=1&sn=d0a8ae41c280de196f8f439561928f3f&chksm=e981e0e5def669f386ca16ee67c3658df8f2650bc74e1ee56d46ae0afc42a8cf8ae9d0b09f76&scene=178&cur_album_id=2241646955158355975#rd
#### 什么是InnoDB行格式？
我们平时很少操作行格式，所以对这个概念可能不是很清楚。其实InnoDB存储引擎为我们提供了4种不同的行格式
```
DYNAMIC（默认的行格式）
COMPACT
REDUNDANT
COMPRESSED
```
一条完整的记录可以分为「记录的额外信息」和「真实数据信息」两部分，4种行格式的不同也主要体现在「真实数据信息」这一部分。也就是说，不同的行格式采用了不同的数据格式来存储我们的真实数据，至于有什么具体的不同，对我们这篇文章并不重要，不需要关注。
#### InnoDB页和InnoDB行格式都有哪些字段信息？
数据页
![](Pasted%20image%2020240102163912.png)
`FIL_PAGE_OFFSET`InnoDB页的页号，相当于这个页的身份证
`FIL_PAGE_PREV`，`FIL_PAGE_NEXT`每个页之间都是双向链表
`FIL_PAGE_TYPE`InnoDB页的种类很多，比如我们这篇文章讲的数据页，还有其他的比如存放`Insert Buffer`信息的页，存放`undo日志`信息的页等，这个字段就是用来标识页面的类型的
`PAGE_N_DIR_SLOTS`这个字段保存的就是槽的个数了，二分法就是根据这个字段的值来确定`high`的值 **`PAGE_LAST_INSERT`**当前页面最后插入记录的位置，当有新记录插入的时候，直接读取这个数据，将新记录放到相应位置就可以了
`PAGE_N_RECS`该页中记录的数量（不包括最小和最大记录）
`Page Directory`，槽就是保存在了这个字段信息里。

行记录
`Infimum`伪记录单独分成一个组
`Supremum`伪记录所在分组的记录条数只能在1～8条之间
其余分组的记录条数只能在4～8条之间
![](Pasted%20image%2020240102164229.png)
小组长的`n_owned`值是组员的个数（包括自己），组员的`n_owned`值就是0。

```
没有设置主键的话是怎么存储的?

当我们没有设置主键的时候，为了防止这种情况，InnoDB会优先选取一个`Unique键`作为主键，如果表中连`Unique键`也没有的话，就会自动为每一条记录添加一个叫做`DB_ROW_ID`的列作为默认主键，只不过这个主键我们看不到罢了。
```

```
为什么推荐使用自增ID作为主键，而不推荐使用UUID？

除了UUID主键索引占据大量空间的问题之外，在插入数据的资源开销上，自增ID也远小于UUID。由于数据页中的记录是按照主键从小到大进行串联的，自增ID决定了后来插入的记录一定会排列在上一条记录的后面，只需要简单添加`next_record`指针就可以了；如果当前数据页写满，那就放心地直接插入新的数据页中就可以了。
而UUID不同，它的大小顺序是不确定的，后来插入的记录有可能（而且概率相当大）插入到上一条记录之前（甚至是当前数据页之前），这就意味着需要遍历当前数据页的记录（或者先找到相关的数据页），然后找到自己的位置进行插入；如果当前数据页写满了，只能先找到适合自己位置的数据页，然后在数据页中遍历记录找到自己的合适位置进行插入。
因此使用UUID的方式插入记录花费的时间更长。
```

#### InnoDB设计者如何设计高效算法，快速在一个页中搜索记录。
在一个数据页中，用户记录是按照主键由小到大的顺序串联而成的单向链表(分组)。基于组进行二分搜索

### MySQL索引
![](Pasted%20image%2020240103111738.png)
####  什么是索引
索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是**索引是数据的目录**。
#### 索引的分类
- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

#### 练习题
https://xiaolincoding.com/mysql/index/index_interview.html
``` 
为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？

1、B+Tree vs B Tree
B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。
另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。

2、B+Tree vs 二叉树
对于有 N 个叶子节点的 B+Tree，其搜索复杂度为`O(logdN)`，其中 d 表示节点允许的最大子节点个数为 d 个。
在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。
而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 `O(logN)`，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。

3、B+Tree vs Hash
Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。
但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。
```

```
Q1: `select * from t_table where a > 1 and b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？

 **a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引**
```

```
Q2: `select * from t_table where a >= 1 and b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？

 **a 和 b 字段都用到了联合索引进行索引查询**
```

```
Q3: `SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？

**a 和 b 字段都用到了联合索引进行索引查询**。
```

```
Q4: `SELECT * FROM t_user WHERE name like 'j%' and age = 22`，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？

 **a 和 b 字段都用到了联合索引进行索引查询**
```

综上所示，**联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配，前面我也用了四个例子说明了**


```
这里出一个题目，针对针对下面这条 SQL，你怎么通过索引来提高查询效率呢？
select * from order where status = 1 order by create_time asc

但是更好的方式给 status 和 create_time 列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。
```
![](Pasted%20image%2020240103112616.png)

#### 从数据页角度看B+树
https://xiaolincoding.com/mysql/index/page.html
![](Pasted%20image%2020240103112940.png)
```
InnoDB 是如何存储数据的？

...自行描述
**InnoDB 的数据是按「数据页」为单位来读写的**，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。默认大小是 16KB**
**数据页中的记录按照「主键」顺序组成单向链表**
**页目录就是由多个槽组成的，槽相当于分组记录的索引**
- 第一个分组中的记录只能有 1 条记录；
- 最后一个分组中的记录条数范围只能在 1-8 条之间；
- 剩下的分组中记录条数范围只能在 4-8 条之间。
```

```
B+ 树是如何进行查询的？

在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找
```
####  主键索引
**B+树**了。没错，上面我们一步步推导出来的搜索结构就是大名鼎鼎的B+树，而MySQL给它起了一个更响亮的名字——**索引**。
B+树最底层的节点（对应图中存储用户记录的数据页）被称为**叶子节点**，其他的节点自然叫做**非叶子节点**了，更特殊地，B+树最顶部的节点叫做**根节点**。
有一个值得我们关注的细节，这棵B+树的叶子节点存储了我们完整的用户记录（就是我们插入表的所有数据），而且，这是用户记录在InnoDB引擎中的唯一存储方式。也就是所谓的“**索引即数据，数据即索引**”。

更方便的一点是，这个关于主键的索引完全是由InnoDB存储引擎自动生成的，不需要我们显式地书写创建索引的语句。这个索引叫做**主键索引**，又叫做**聚簇索引**。

主键索引有两个特点：
1. 按照主键的大小对用户记录和数据页进行排序，记录用单向链表连接，数据页使用双向链表连接；
2. B+树的叶子节点保存了用户的完整记录。
#### 普通索引
以name建立索引
这棵B+树和聚簇索引的B+树有点区别
1. 叶子节点存放的不再是完整的用户记录，而是只记录`name`列和主键值；
2. 数据页中存放的用户记录和目录项记录由原本的按照主键排序变为按照`name`列排序；
3. 目录项记录除了存储索引列（`name`）和页号之外，同时还存储了主键值；

有了这棵B+树，你就可以通过`name`列快速找到主键值了，查找的方式和根据主键值查找用户记录的方式完全一样，只不过前者查到的是主键值，后者查找到的是一条完整的用户记录罢了。
现在得到主键的id了，然后根据主键id到主键索引中查找到完整的用户记录，这个过程叫做回表。如果没有为`name`列设置唯一性约束，那就可能找到多个符合条件的主键id，多回几次表就可以了。
对`name`这种单个列添加的索引叫做**普通索引**，也叫**二级索引**。

#### 联合索引
假设我们为`name`列和`phone`列建立联合索引（注意我描述的顺序），自然也是创建一棵B+树，这棵B+树和之前又稍微有点不同：
1. 叶子节点存放的是`name`列、`phone`列和主键值；
2. 目录项记录除了存储索引列（`name`、`phone`）和页号之外，同时还存储了主键值；
3. 数据页中存放的用户记录和目录项记录由原本的按照主键排序变为按照`name`列排序，如果`name`列相同，那就按照`phone`列排序；

还是和二级索引一样，利用B+树快速定位到数据页，然后页内快速定位到记录，找到记录中的主键id，再回表，如果找到多条符合条件的记录，就多回几次表。

联合索引在B树上的存储结构及数据的查找方式
https://juejin.cn/post/6844904073955639304
#### 怎么用好索引
https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&mid=2247484338&idx=1&sn=f753421c70f0e436c040af9e969c3331&chksm=e981e01cdef6690ae6e4bec7c92b436019f5f30e02f35524ca8e144a92b8aa743fc2c51d2c27&scene=178&cur_album_id=2241646955158355975#rd
![](Pasted%20image%2020240102174258.png)
练习题: 
假设a为主键索引, bcd为联合索引
```mysql
select * from T1 where b = 12 and c = 14 and d = 3;-- 全值索引匹配 三列都用到
select * from T1 where b = 12 and c = 14 and e = 'xml';-- 应用到两列索引
select * from T1 where b = 12 and e = 'xml';-- 应用到一列索引
select * from T1 where b = 12  and c >= 14 and e = 'xml';-- 应用到bc两列列索引及索引条件下推优化
select * from T1 where b = 12  and d = 3;-- 应用到一列索引  因为不能跨列使用索引 没有c列 连不上
select * from T1 where c = 14  and d = 3;-- 无法应用索引，违背最左匹配原则
```

### 为什么不建议使用SELECT * ？
https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&mid=2247484373&idx=1&sn=f33e3311674b4ae2899a85f56d34a2ae&chksm=e981e07bdef6696d1eb318902cd98c2d59c7565d7b42646f81842411a31529d7c27cfbffac46&scene=178&cur_album_id=2241646955158355975#rd

1. 不必要的磁盘I/O
2. 加重网络时延
3. 无法使用覆盖索引
4. 可能拖慢JOIN连接查询
对于连接查询而言，驱动表只会被访问一遍，而被驱动表却要被访问好多遍，具体的访问次数取决于驱动表中符合查询记录的记录条数。由于已经强制确定了驱动表和被驱动表，下面我们说一下两表连接的本质：
1. `t1`作为驱动表，针对驱动表的过滤条件，执行对`t1`表的查询。因为没有过滤条件，也就是获取`t1`表的所有数据；
2. 对上一步中获取到的结果集中的每一条记录，都分别到被驱动表中，根据连接过滤条件查找匹配记录

这种方法最简单，但同时性能也是最差，这种方式叫做`嵌套循环连接`（Nested-LoopJoin，NLJ）。怎么加快连接速度呢？

-其中一个办法就是创建索引，最好是在被驱动表（`t2`）连接条件涉及到的字段上创建索引，毕竟被驱动表需要被查询好多次，而且对被驱动表的访问本质上就是个单表查询而已（因为`t1`结果集定了，每次连接`t2`的查询条件也就定死了）。
既然使用了索引，为了避免重蹈无法使用覆盖索引的覆辙，我们也应该尽量不要直接`SELECT *`，而是将真正用到的字段作为查询列，并为其建立适当的索引

-但是如果我们不使用索引，MySQL就真的按照嵌套循环查询的方式进行连接查询吗？当然不是，毕竟这种嵌套循环查询实在是太慢了！
在MySQL8.0之前，MySQL提供了`基于块的嵌套循环连接`（Block Nested-Loop Join，BLJ）方法，MySQL8.0又推出了`hash join`方法，这两种方法都是为了解决一个问题而提出的，那就是尽量减少被驱动表的访问次数。
这两种方法都用到了一个叫做`join buffer`的固定大小的内存区域，其中存储着若干条驱动表结果集中的记录（这两种方法的区别就是存储的形式不同而已），如此一来，把被驱动表的记录加载到内存的时候，一次性和`join buffer`中多条驱动表中的记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的I/O代价，大大减少了重复从磁盘上加载被驱动表的代价。使用`join buffer`的过程如下图所示：
![](Pasted%20image%2020240102190610.png)
最好的情况是`join buffer`足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。我们可以使用`join_buffer_size`这个系统变量进行配置，默认大小为`256KB`。如果还装不下，就得分批把驱动表的结果集放到`join buffer`中了，在内存中对比完成之后，清空`join buffer`再装入下一批结果集，直到连接完成为止。

重点来了！并不是驱动表记录的所有列都会被放到`join buffer`中，只有查询列表中的列和过滤条件中的列才会被放到`join buffer`中，所以再次提醒我们，最好不要把`*`作为查询列表，只需要把我们关心的列放到查询列表就好了，这样还可以在`join buffer`中放置更多的记录，减少分批的次数，也就自然减少了对被驱动表的访问次数。
### MySQL优化的5个维度
https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&mid=2247484458&idx=1&sn=33a19312e0ec6f566e7d6b266a169763&chksm=e981e784def66e9287aee4b5e456399e94af6ad09ec2b0eb585811ae1d315363c95ae9693f2c&scene=178&cur_album_id=2241646955158355975#rd
![](Pasted%20image%2020240102193058.png)

### 事务的隔离级别与MVCC
https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&mid=2247484497&idx=1&sn=1cbf4fe107b01f6d53e4b2ad4bb09a83&chksm=e981e7ffdef66ee91b2def2b0e42511c2e75fd19e2040b1ec03e6653fec2300250c057dd1b1e&scene=178&cur_album_id=2241646955158355975#rd

https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7

### MySQL锁，锁的到底是什么？
https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&mid=2247484827&idx=1&sn=51de4e6579bb0a0312e405acf1aa6721&chksm=e981e635def66f2391717267acbf62f90c0b4dbff0233514762ef20c318d8950dcd4ab6eeac5&scene=178&cur_album_id=2241646955158355975#rd

