MySQL索引原理及慢查询优化
https://tech.meituan.com/2014/06/30/mysql-index.html
select count详解
https://juejin.cn/post/6864874941288972296
### 一条SELECT语句是如何执行的
https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&mid=2247484069&idx=1&sn=d40d90ab9e3041757262be5192a46e9e&chksm=e981e10bdef6681dde2ede9c1293e4b379fb827ab3c7d64ae828311c4ee14e19e20d7537d5f0&scene=178&cur_album_id=2241646955158355975#rd
![](Pasted%20image%2020240102150910.png)
1. 处理连接，本质上是进程间通信的过程(TCP/IP，也可以采用管道和共享内存的方式); 默认最大连接数为151。默认8小时自动断开连接
4. 查询缓存(默认关闭, 8.0之后移除了缓存功能)
5. 解析器 (词法分析，语法分析)
6. 预处理器(解决解析器无法解析的语义, 如检查表和列名是否存在)
7. 查询优化器(根据解析树生成不同的执行计划（Execution Plan），然后选择一种最优的执行计划，MySQL 里面使用的是基于开销（cost）的优化器，哪种执行计划开销最小，就用哪种，比如1. 当我们对多张表进行关联查询的时候，以哪个表的数据作为基准表。2. 有多个索引可以使用的时候，选择哪个索引。)
8. 执行计划
9. 存储引擎
在创建表的时候可以指定当前表的存储引擎，如果没有指定，默认的存储引擎为InnoDB，如果想显式指定存储引擎，可以这样
```mysql
CREATE TABLE `t_user_innodb` (  
  `id` int(11) NOT NULL AUTO_INCREMENT,  
  PRIMARY KEY (`id`)  
) ENGINE=innodb DEFAULT CHARSET=utf8mb4;
```

**MylSAM**
应用范围比较小，表级锁定限制了读/写的性能，因此在Web和数据仓库配置中，通常用于只读或以读为主的工作。
特点:
- 支持表级别的锁（插入和更新会锁表），不支持事务
- 拥有较高的插入（insert）和查询（select）速度
- 存储了表的行数（count速度更快）
```
怎么快速向数据库插入100万条数据？
可以先用MylSAM插入数据，然后修改存储引擎为InnoDB。
```

**InnoDB**
MySQL 5.7及更新版中的默认存储引擎。InnoDB是一个事务安全（与ACID兼容）的MySQL 存储引擎，它具有提交、回滚和崩溃恢复功能来保护用户数据。InnoDB行级锁（不升级为更粗粒度的锁）和Oracle风格的一致非锁读提高了多用户并发性。InnoDB将用户数据存储在聚集索引中，以减少基于主键的常见查询的I/O。为了保持数据完整性，InnoDB还支持外键引用完整性约束。

特点：
- 支持事务，支持外键，因此数据的完整性、一致性更高；
- 支持行级别的锁和表级别的锁；
- 支持读写并发，写不阻塞读（MVCC）；
- 特殊的索引存放方式，可以减少IO，提升査询效率。

**Memory**
将所有数据存储在RAM中，以便快速访问。这个引擎以前被称为堆引擎。
特点: 
- 把数据放在内存里面，读写的速度很快，但是数据库重启或者崩溃，数据会全部消失；
- 只适合做临时表。

如何选择存储引擎
- 如果对数据一致性要求比较高，需要事务支持，可以选择InnoDB。
- 如果数据查询多更新少，对查询性能要求比较高，可以选择MyISAM。
- 如果需要一个用于查询的临时表，可以选择Memory。

### 一条SQL更新语句是如何执行的
https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&mid=2247484093&idx=1&sn=f0fb512d536701c3e0ecdbf330fd6f9d&chksm=e981e113def668058493e9102039b45034312946326fca9906744615b4547a364aa7bc445c16&scene=178&cur_album_id=2241646955158355975#rd
![](Pasted%20image%2020240102155656.png)
1. 客户端发送更新命令到MySQL服务器，经过处理连接、解析优化等步骤；
2. Server层向InnoDB存储引擎要id=1的这条记录；
3. 事务开始, 存储引擎先从缓存中查找这条记录，有的话直接返回，没有则从磁盘加载到缓存中然后返回；
4. Server层执行器修改这条记录的name字段值；
5. 存储引擎更新修改到内存中；
6. 存储引擎记录redo日志，并将状态设置为`prepare`状态；
7. 记录redo log
8. 存储引擎通知执行器，修改完毕，可以进行事务提交；
9. Server先写了个binlog；
10. Server提交事务；
11. 存储引擎将redo日志中和当前事务相关的记录状态设置为`commit`状态。

背景知识: 
#### 什么是InnoDB页？Buffer Pool是什么？为什么这么设计？
InnoDB页
InnoDB存储引擎将数据划分为若干个页，以页作为磁盘和内存之间交互的最小单位。InnoDB中页的大小默认为16KB。也就是默认情况下，一次最少从磁盘中读取16KB的数据到内存中，一次最少把内存中16KB的内容刷新到磁盘上。

缓冲池Buffer Pool
为了缓存磁盘的页，InnoDB在MySQL服务器启动时会向操作系统申请一片连续的内存区域，这片内存区域就是**Buffer Pool**
很容易理解，为了更好地缓存页数据，Buffer Pool对应的一片连续内存空间也被划分为若干个页，而且默认情况下，Buffer Pool页的大小和InnoDB页大小一样，都是16KB。为了区分两种不同的页，我们将Buffer Pool中的页面称为缓冲页

读取数据的时候，InnoDB先判断数据是否在Buffer Pool中，如果是，则直接读取数据进行操作，不用再次从磁盘加载；如果不是，则从磁盘加载到Buffer Pool中，然后读取数据进行操作。
修改数据的时候，也是将数据先写到Buffer Pool缓冲页中，而不是每次更新操作都直接写入磁盘。当缓冲页中的数据和磁盘文件不一致的时候，缓冲页被称为脏页。

那么脏页是什么时候被同步到磁盘呢？
InnoDB中有专门的后台线程每隔一段时间会把脏页的多个修改刷新到磁盘上，这个动作叫做「刷脏」
#### 什么是表空间？不同存储引擎的表在文件系统的底层表示上有什么区别？
表空间
为了更好地管理页，MySQL又设计了「表空间」的概念。表空间又有很多类型，具体类型我们不需要知道，我们只需要知道，一个表空间可以划分成很多个InnoDB页，InnoDB表数据都存储在某个表空间的页中。
为了方便我们定位，MySQL贴心地为表空间设计了一个唯一标识——表空间ID（space ID）。同理，InnoDB页也有自己的唯一编号——页号（page number）。
因此，我们可以这么认为。给定表空间ID和页号以及页的偏移量，我们就可以定位到InnoDB页的某条记录，也就是数据库表的某条记录。

InnoDB是如何存储表数据的
「表空间」是InnoDB存储引擎独有的概念。
我们看到`t_user_innodb`表在数据库对应的`test`目录下会生成以下两个文件
- t_user_innodb.frm
- t_user_innodb.ibd
其中，t_user_innodb.ibd就是`t_user_innodb`表对应的表空间在文件系统上的表示；t_user_innodb.frm用来描述表的结构，如表有哪些列，列的类型是什么等。

MyISAM是如何存储表数据的
和InnoDB不同，MyISAM没有表空间的概念，表的数据和索引全都直接存放在对应的数据库子目录下，可以看到`t_user_myisam`对应了三个文件
- t_user_myisam.MYD
- t_user_myisam.MYI
- t_user_myisam.frm
其中，t_user_myisam.MYD表示表的数据文件，也就是我们实际看到的数据表的内容；t_user_myisam.MYI表示表的索引文件，为该表创建的索引都会存放在这个文件中；t_user_myisam.frm用来描述表的结构。

MEMORY是如何存储表数据的
MEMORY存储引擎对应的数据表只有一个描述表结构的文件t_user_memory.frm
#### MySQL的三种日志文件redo日志、undo日志、binlog分别是什么？为什么需要这么多种类型的日志？
##### redo日志(数据恢复)
InnoDB中有专门的后台线程每隔一段时间会把脏页的多个修改刷新到磁盘上，这个动作叫做「刷脏」
不定时刷脏又带来一个问题。如果脏页的数据还没有刷新到磁盘上，此时数据库突然宕机或重启，这些数据就会丢失。

首先想到的最简单粗暴的解决方案就是在事务提交之前，把该事务修改的所有页面都刷新到磁盘。但是上文说过，页是内存和磁盘交互的最小单位，如果只修改了1个字节，却要刷新16KB的数据到磁盘上，不得不说太浪费了，此路不通！

所以，必须要有一个持久化的措施。
为了解决这个问题，InnoDB把对所有页的更新操作（再强调一遍，包含INSERT、UPDATE、DELETE）专门写入一个日志文件。
当有未同步到磁盘中的数据时，数据库在启动的时候，会根据这个日志文件进行数据恢复。我们常说的关系型数据库的`ACID`特性中的`D`（持久性），就是通过这个日志来实现的。
这个日志文件就是大名鼎鼎的**redo日志**。

```
这就出现了一个有意思的问题，刷新磁盘和写redo日志都是进行磁盘操作，为什么不直接把数据刷新到磁盘中呢？

因为刷脏是随机I/O，而记录日志是顺序I/O（连续写的），顺序I/O效率更高，本质上是数据集中存储和分散存储的区别。因此先把修改写入日志文件，在保证了内存数据的安全性的情况下，可以延迟刷盘时机，进而提升系统吞吐。
```
redo日志位于MySQL数据目录下，默认有`ib_logfile0`和`ib_logfile1`两个文件
可以发现，两个redo日志文件的大小都是50331648，默认48MB。为什么这个大小是固定的呢？因为如果我们要使用顺序I/O，就必须在申请磁盘空间的时候一次性决定申请的空间大小，这样才能保证申请的磁盘空间在地址上的连续性。
这也就决定了redo日志的旧数据会被覆盖，一旦文件被写满，就会触发Buffer Pool脏页到磁盘的同步，以腾出额外空间记录后面的修改。

##### undo日志(事务回滚)
undo log（撤销日志或回滚日志）记录了事务发生之前的数据状态，分为insert undo log和update undo log。
如果修改数据时出现异常，可以用 undo log来实现回滚操作（保持原子性）。可以理解为undo日志记录的是反向的操作，比如INSERT操作会记录DELETE，UPDATE会记录UPDATE之前的值，和redo日志记录在哪个物理页面做了什么操作不同，所以这是一种逻辑格式的日志。
undo日志和redo日志与事务密切相关，被统称为「事务日志」。
##### binlog日志
从MySQL整体架构来看，其实可以分成两部分
- Server 层，它主要做的是 MySQL功能层面的事情，比如处理连接、解析优化等；
- 存储引擎层，负责存储相关的具体事宜。
redo日志是InnoDB存储引擎特有的日志，而Server层也有自己的日志，称为 binlog（归档日志），它可以被所有存储引擎使用
```
为什么有了redo日志还需要 binlog？

我想你可能会问出这个问题，实际上，更准确的问法是为什么有了binlog还需要有redo日志？主要有以下几个原因。
1. binlog日志是用来归档的，binlog以事件的形式记录了所有的 DDL和 DML 语句（因为它记录的是操作而不是 数据值，属于逻辑日志），但是不具备宕机恢复的功能，因为可能没有来得及刷新脏页，造成脏页数据的丢失，而这些操作也没有保存到binlog中从而造成数据丢失；
2. 因为最开始MySQL里并没有InnoDB存储引擎。MySQL自带的引擎是MyISAM，但是 MyISAM没有崩溃恢复的能力，InnoDB后来以插件的形式被引入，顺便带来了redo日志；
3. binlog记录的是关于一个事务的具体操作内容，即该日志是逻辑日志。而redo日志记录的是关于每个页的更改的物理情况。功能压根不是一回事儿。
```

binlog日志的作用-主从复制
binlog是实现MySQL主从复制功能的核心组件。
master节点会将所有的写操作记录到binlog中，slave节点会有专门的I/O线程读取master节点的binlog，将写操作同步到当前所在的slave节点
![](Pasted%20image%2020240102160654.png)
```
假如这条更新语句已经被写入到了redo日志，还没来得及写binlog的时候，MySQL宕机重启了，我们看一下会发生什么?
```
因为redo日志可以在重启的时候用于恢复数据，所以写入磁盘的是chanmufeng1994。但是binlog里面没有记录这个逻辑日志，所以这时候用binlog去恢复数据或者同步到从库，就会出现数据不一致的情况。
所以在写两个日志的情况下，就类似于「分布式事务」的情况，如果你不清楚分布式事务是个什么东西也没关系，我在之后的文章会介绍到。能够明确的就是redo日志和binlog日志如果单纯依次进行提交是无法保证两种日志都写成功或者都写失败的。

我们需要「两阶段提交」。

```
两阶段提交不是MySQL的专利，两阶段提交是一种跨系统维持数据逻辑一致性的常见方案，尤其在分布式事务上，所以请读者重点体会思想
```

我们把redo日志的提交分成两步，两步中redo日志的状态分别是`prepare`和`commit`。步骤如下
1. InnoDB存储引擎将更改更新到内存中后，同时将这个更新操作记录到redo日志里面，此时redo日志处于`prepare`状态；
2. 执行器生成这个操作的binlog，并将binlog刷盘；
3. 执行器调用InnoDB的提交事务接口，InnoDB把刚刚写入的redo日志改成`commit`状态。至此，所有操作完成。

### 为什么MySQL的主键查询这么快
https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&mid=2247484235&idx=1&sn=d0a8ae41c280de196f8f439561928f3f&chksm=e981e0e5def669f386ca16ee67c3658df8f2650bc74e1ee56d46ae0afc42a8cf8ae9d0b09f76&scene=178&cur_album_id=2241646955158355975#rd
#### 什么是InnoDB行格式？
我们平时很少操作行格式，所以对这个概念可能不是很清楚。其实InnoDB存储引擎为我们提供了4种不同的行格式
```
DYNAMIC（默认的行格式）
COMPACT
REDUNDANT
COMPRESSED
```
一条完整的记录可以分为「记录的额外信息」和「真实数据信息」两部分，4种行格式的不同也主要体现在「真实数据信息」这一部分。也就是说，不同的行格式采用了不同的数据格式来存储我们的真实数据，至于有什么具体的不同，对我们这篇文章并不重要，不需要关注。
#### InnoDB页和InnoDB行格式都有哪些字段信息？
数据页
![](Pasted%20image%2020240102163912.png)
`FIL_PAGE_OFFSET`InnoDB页的页号，相当于这个页的身份证
`FIL_PAGE_PREV`，`FIL_PAGE_NEXT`每个页之间都是双向链表
`FIL_PAGE_TYPE`InnoDB页的种类很多，比如我们这篇文章讲的数据页，还有其他的比如存放`Insert Buffer`信息的页，存放`undo日志`信息的页等，这个字段就是用来标识页面的类型的
`PAGE_N_DIR_SLOTS`这个字段保存的就是槽的个数了，二分法就是根据这个字段的值来确定`high`的值 **`PAGE_LAST_INSERT`**当前页面最后插入记录的位置，当有新记录插入的时候，直接读取这个数据，将新记录放到相应位置就可以了
`PAGE_N_RECS`该页中记录的数量（不包括最小和最大记录）
`Page Directory`，槽就是保存在了这个字段信息里。

行记录
`Infimum`伪记录单独分成一个组
`Supremum`伪记录所在分组的记录条数只能在1～8条之间
其余分组的记录条数只能在4～8条之间
![](Pasted%20image%2020240102164229.png)
小组长的`n_owned`值是组员的个数（包括自己），组员的`n_owned`值就是0。

```
没有设置主键的话是怎么存储的?

当我们没有设置主键的时候，为了防止这种情况，InnoDB会优先选取一个`Unique键`作为主键，如果表中连`Unique键`也没有的话，就会自动为每一条记录添加一个叫做`DB_ROW_ID`的列作为默认主键，只不过这个主键我们看不到罢了。
```

```
为什么推荐使用自增ID作为主键，而不推荐使用UUID？

除了UUID主键索引占据大量空间的问题之外，在插入数据的资源开销上，自增ID也远小于UUID。由于数据页中的记录是按照主键从小到大进行串联的，自增ID决定了后来插入的记录一定会排列在上一条记录的后面，只需要简单添加`next_record`指针就可以了；如果当前数据页写满，那就放心地直接插入新的数据页中就可以了。
而UUID不同，它的大小顺序是不确定的，后来插入的记录有可能（而且概率相当大）插入到上一条记录之前（甚至是当前数据页之前），这就意味着需要遍历当前数据页的记录（或者先找到相关的数据页），然后找到自己的位置进行插入；如果当前数据页写满了，只能先找到适合自己位置的数据页，然后在数据页中遍历记录找到自己的合适位置进行插入。
因此使用UUID的方式插入记录花费的时间更长。
```

#### InnoDB设计者如何设计高效算法，快速在一个页中搜索记录。
在一个数据页中，用户记录是按照主键由小到大的顺序串联而成的单向链表(分组)。基于组进行二分搜索

### MySQL索引
####  主键索引
**B+树**了。没错，上面我们一步步推导出来的搜索结构就是大名鼎鼎的B+树，而MySQL给它起了一个更响亮的名字——**索引**。
B+树最底层的节点（对应图中存储用户记录的数据页）被称为**叶子节点**，其他的节点自然叫做**非叶子节点**了，更特殊地，B+树最顶部的节点叫做**根节点**。
有一个值得我们关注的细节，这棵B+树的叶子节点存储了我们完整的用户记录（就是我们插入表的所有数据），而且，这是用户记录在InnoDB引擎中的唯一存储方式。也就是所谓的“**索引即数据，数据即索引**”。

更方便的一点是，这个关于主键的索引完全是由InnoDB存储引擎自动生成的，不需要我们显式地书写创建索引的语句。这个索引叫做**主键索引**，又叫做**聚簇索引**。

主键索引有两个特点：
1. 按照主键的大小对用户记录和数据页进行排序，记录用单向链表连接，数据页使用双向链表连接；
2. B+树的叶子节点保存了用户的完整记录。
#### 普通索引
以name建立索引
这棵B+树和聚簇索引的B+树有点区别
1. 叶子节点存放的不再是完整的用户记录，而是只记录`name`列和主键值；
2. 数据页中存放的用户记录和目录项记录由原本的按照主键排序变为按照`name`列排序；
3. 目录项记录除了存储索引列（`name`）和页号之外，同时还存储了主键值；

有了这棵B+树，你就可以通过`name`列快速找到主键值了，查找的方式和根据主键值查找用户记录的方式完全一样，只不过前者查到的是主键值，后者查找到的是一条完整的用户记录罢了。
现在得到主键的id了，然后根据主键id到主键索引中查找到完整的用户记录，这个过程叫做回表。如果没有为`name`列设置唯一性约束，那就可能找到多个符合条件的主键id，多回几次表就可以了。
对`name`这种单个列添加的索引叫做**普通索引**，也叫**二级索引**。

#### 联合索引
假设我们为`name`列和`phone`列建立联合索引（注意我描述的顺序），自然也是创建一棵B+树，这棵B+树和之前又稍微有点不同：
1. 叶子节点存放的是`name`列、`phone`列和主键值；
2. 目录项记录除了存储索引列（`name`、`phone`）和页号之外，同时还存储了主键值；
3. 数据页中存放的用户记录和目录项记录由原本的按照主键排序变为按照`name`列排序，如果`name`列相同，那就按照`phone`列排序；

还是和二级索引一样，利用B+树快速定位到数据页，然后页内快速定位到记录，找到记录中的主键id，再回表，如果找到多条符合条件的记录，就多回几次表。

联合索引在B树上的存储结构及数据的查找方式
https://juejin.cn/post/6844904073955639304
#### 怎么用好索引
https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&mid=2247484338&idx=1&sn=f753421c70f0e436c040af9e969c3331&chksm=e981e01cdef6690ae6e4bec7c92b436019f5f30e02f35524ca8e144a92b8aa743fc2c51d2c27&scene=178&cur_album_id=2241646955158355975#rd
![](Pasted%20image%2020240102174258.png)
练习题: 
假设a为主键索引, bcd为联合索引
```mysql
select * from T1 where b = 12 and c = 14 and d = 3;-- 全值索引匹配 三列都用到
select * from T1 where b = 12 and c = 14 and e = 'xml';-- 应用到两列索引
select * from T1 where b = 12 and e = 'xml';-- 应用到一列索引
select * from T1 where b = 12  and c >= 14 and e = 'xml';-- 应用到bc两列列索引及索引条件下推优化
select * from T1 where b = 12  and d = 3;-- 应用到一列索引  因为不能跨列使用索引 没有c列 连不上
select * from T1 where c = 14  and d = 3;-- 无法应用索引，违背最左匹配原则
```

### 为什么不建议使用SELECT * ？
https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&mid=2247484373&idx=1&sn=f33e3311674b4ae2899a85f56d34a2ae&chksm=e981e07bdef6696d1eb318902cd98c2d59c7565d7b42646f81842411a31529d7c27cfbffac46&scene=178&cur_album_id=2241646955158355975#rd

1. 不必要的磁盘I/O
2. 加重网络时延
3. 无法使用覆盖索引
4. 可能拖慢JOIN连接查询
对于连接查询而言，驱动表只会被访问一遍，而被驱动表却要被访问好多遍，具体的访问次数取决于驱动表中符合查询记录的记录条数。由于已经强制确定了驱动表和被驱动表，下面我们说一下两表连接的本质：
1. `t1`作为驱动表，针对驱动表的过滤条件，执行对`t1`表的查询。因为没有过滤条件，也就是获取`t1`表的所有数据；
2. 对上一步中获取到的结果集中的每一条记录，都分别到被驱动表中，根据连接过滤条件查找匹配记录

这种方法最简单，但同时性能也是最差，这种方式叫做`嵌套循环连接`（Nested-LoopJoin，NLJ）。怎么加快连接速度呢？

-其中一个办法就是创建索引，最好是在被驱动表（`t2`）连接条件涉及到的字段上创建索引，毕竟被驱动表需要被查询好多次，而且对被驱动表的访问本质上就是个单表查询而已（因为`t1`结果集定了，每次连接`t2`的查询条件也就定死了）。
既然使用了索引，为了避免重蹈无法使用覆盖索引的覆辙，我们也应该尽量不要直接`SELECT *`，而是将真正用到的字段作为查询列，并为其建立适当的索引

-但是如果我们不使用索引，MySQL就真的按照嵌套循环查询的方式进行连接查询吗？当然不是，毕竟这种嵌套循环查询实在是太慢了！
在MySQL8.0之前，MySQL提供了`基于块的嵌套循环连接`（Block Nested-Loop Join，BLJ）方法，MySQL8.0又推出了`hash join`方法，这两种方法都是为了解决一个问题而提出的，那就是尽量减少被驱动表的访问次数。
这两种方法都用到了一个叫做`join buffer`的固定大小的内存区域，其中存储着若干条驱动表结果集中的记录（这两种方法的区别就是存储的形式不同而已），如此一来，把被驱动表的记录加载到内存的时候，一次性和`join buffer`中多条驱动表中的记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的I/O代价，大大减少了重复从磁盘上加载被驱动表的代价。使用`join buffer`的过程如下图所示：
![](Pasted%20image%2020240102190610.png)
最好的情况是`join buffer`足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。我们可以使用`join_buffer_size`这个系统变量进行配置，默认大小为`256KB`。如果还装不下，就得分批把驱动表的结果集放到`join buffer`中了，在内存中对比完成之后，清空`join buffer`再装入下一批结果集，直到连接完成为止。

重点来了！并不是驱动表记录的所有列都会被放到`join buffer`中，只有查询列表中的列和过滤条件中的列才会被放到`join buffer`中，所以再次提醒我们，最好不要把`*`作为查询列表，只需要把我们关心的列放到查询列表就好了，这样还可以在`join buffer`中放置更多的记录，减少分批的次数，也就自然减少了对被驱动表的访问次数。
### MySQL优化的5个维度
https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&mid=2247484458&idx=1&sn=33a19312e0ec6f566e7d6b266a169763&chksm=e981e784def66e9287aee4b5e456399e94af6ad09ec2b0eb585811ae1d315363c95ae9693f2c&scene=178&cur_album_id=2241646955158355975#rd
![](Pasted%20image%2020240102193058.png)

### 事务的隔离级别与MVCC
https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&mid=2247484497&idx=1&sn=1cbf4fe107b01f6d53e4b2ad4bb09a83&chksm=e981e7ffdef66ee91b2def2b0e42511c2e75fd19e2040b1ec03e6653fec2300250c057dd1b1e&scene=178&cur_album_id=2241646955158355975#rd

https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7

### MySQL锁，锁的到底是什么？
https://mp.weixin.qq.com/s?__biz=MzI1MDU0MTc2MQ==&mid=2247484827&idx=1&sn=51de4e6579bb0a0312e405acf1aa6721&chksm=e981e635def66f2391717267acbf62f90c0b4dbff0233514762ef20c318d8950dcd4ab6eeac5&scene=178&cur_album_id=2241646955158355975#rd

