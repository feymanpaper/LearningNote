纯暴力搜索

深度优先搜索是特定于图的一种搜索算法。回溯算法是特定于树结构的搜索算法
那为何回溯算法 =深度优先搜索＋剪枝函数这一说法没有错？因为树是特殊的图

适合解决什么问题？

组合
排列
子集
切割
棋盘
#### 排列
46. 全排列
idx状态表示填充的temp下标, 当填充到下标n时可以记录结果
```go
func permute(nums []int) [][]int {
    n:=len(nums)
    ans:=make([][]int, 0)
    temp:=make([]int, n)
    vis:=make([]bool, n)
    var backtrack func(int)
    backtrack=func(idx int){
        if idx==len(nums){
            t:=make([]int, n)
            //注意要做一次深拷贝
            copy(t, temp)
            ans=append(ans, t)
            return 
        }
        for i:=0; i<n; i++{
            if !vis[i]{
                vis[i]=true
                temp[i]=nums[idx]
                backtrack(idx+1)
                //temp[i]=-1
                vis[i]=false
            }
        }
    }
    backtrack(0)
    return ans
}
```
47. 全排列 II
增加了对nums排序，以及判断nums i和nums i-1是否相等且vis i-1没被选择过
```go
func permuteUnique(nums []int) [][]int {
    n:=len(nums)
    sort.Slice(nums, func(i, j int) bool{
        return nums[i]<nums[j]
    })
    ans:=make([][]int, 0)
    temp:=make([]int, n)
    vis:=make([]bool, n)
    var backtrack func(int)
    backtrack=func(idx int){
        if idx==n{
            t:=make([]int, n)
            copy(t, temp)
            ans=append(ans, t)
            return 
        }
        for i:=0; i<n; i++{
            if vis[i]{
                continue
            }
            if i>=1&&nums[i]==nums[i-1]&&!vis[i-1]{
                continue
            }
            vis[i]=true
            temp[idx]=nums[i]
            backtrack(idx+1)
            //
            vis[i]=false
        }
        return 
    }
    backtrack(0)
    return ans
}
```