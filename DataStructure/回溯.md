纯暴力搜索
深度优先搜索是特定于图的一种搜索算法。回溯算法是特定于树结构的搜索算法
那为何回溯算法 =深度优先搜索＋剪枝函数这一说法没有错？因为树是特殊的图
适合解决什么问题？

组合
排列
子集
切割
棋盘
#### 排列
46. 全排列
idx状态表示填充的temp下标, 当填充到下标n时可以记录结果
```go
func permute(nums []int) [][]int {
    n:=len(nums)
    ans:=make([][]int, 0)
    temp:=make([]int, n)
    vis:=make([]bool, n)
    var backtrack func(int)
    backtrack=func(idx int){
        if idx==len(nums){
            t:=make([]int, n)
            //注意要做一次深拷贝
            copy(t, temp)
            ans=append(ans, t)
            return 
        }
        for i:=0; i<n; i++{
            if !vis[i]{
                vis[i]=true
                temp[i]=nums[idx]
                backtrack(idx+1)
                //temp[i]=-1
                vis[i]=false
            }
        }
    }
    backtrack(0)
    return ans
}
```
47. 全排列 II
增加了对nums排序，以及判断nums i和nums i-1是否相等且vis i-1没被选择过
```go
func permuteUnique(nums []int) [][]int {
    n:=len(nums)
    sort.Slice(nums, func(i, j int) bool{
        return nums[i]<nums[j]
    })
    ans:=make([][]int, 0)
    temp:=make([]int, n)
    vis:=make([]bool, n)
    var backtrack func(int)
    backtrack=func(idx int){
        if idx==n{
            t:=make([]int, n)
            copy(t, temp)
            ans=append(ans, t)
            return 
        }
        for i:=0; i<n; i++{
            if vis[i]{
                continue
            }
            if i>=1&&nums[i]==nums[i-1]&&!vis[i-1]{
                continue
            }
            vis[i]=true
            temp[idx]=nums[i]
            backtrack(idx+1)
            //
            vis[i]=false
        }
        return 
    }
    backtrack(0)
    return ans
}
```
第k个排列
```go
func getPermutation(n int, k int) string {
    var ans string
    path:=make([]byte, n)
    cnt:=0
    vis:=make([]bool, n)
    //搜到第k个直接退出
    var backtrack func(step int) bool
    backtrack = func(step int) bool{
        if step==n{
            cnt++
            if cnt>=k{
                ans=string(path)
                return true
            }
            return false
        }
        for i:=0; i<n; i++{
            if vis[i]{
                continue
            }
            vis[i]=true
            path[step]=byte(i+1+'0')
            if backtrack(step+1){
                return true
            }
            //
            vis[i]=false
        }
        return false
    }
    backtrack(0)
    return ans
}
```
#### 组合
77. 组合
```go
func combine(n int, k int) [][]int {
    ans:=make([][]int, 0)
    temp:=make([]int, k)
    var backtrack func(int, int)
    // 增加一个状态维护起始st
    backtrack=func(idx, st int){
        if idx==k{
            t:=make([]int, k)
            copy(t, temp)
            ans=append(ans, t)
            return 
        }
        for i:=st; i<=n; i++{
            temp[idx]=i
            backtrack(idx+1, i+1)
            //
        }
    }
    backtrack(0, 1)
    return ans
}
```
39. 组合总和
```go
func combinationSum(candidates []int, target int) [][]int {
    sort.Slice(candidates, func(i, j int) bool{
        return candidates[i]<candidates[j]
    })
    n:=len(candidates)
    ans:=make([][]int, 0)
    path:=make([]int, 0)
    sum:=0
    var backtrack func(int)
    backtrack = func(idx int){
        if sum>target{
            return 
        }
        if sum==target{
            t:=make([]int, len(path))
            copy(t, path)
            ans=append(ans, t)
            return
        }
        for i:=idx; i<n; i++{
            if sum+candidates[i]>target{
                break
            }
            sum+=candidates[i]
            path=append(path, candidates[i])
            backtrack(i)
            path=path[:len(path)-1]
            sum-=candidates[i]
        }
        return
    }
    backtrack(0)
    return ans
}
```
40. 组合总和 II

```go
func combinationSum2(candidates []int, target int) [][]int {
    n:=len(candidates)
    sort.Slice(candidates, func(i, j int) bool{
        return candidates[i]<candidates[j]
    })
    ans:=make([][]int, 0)
    path:=make([]int, 0)
    sum:=0
    var backtrack func(idx int)
    backtrack=func(idx int){
        if sum>target{
            return 
        }
        if sum==target{
            t:=make([]int, len(path))
            copy(t, path)
            ans=append(ans, t)
            return 
        }
        for i:=idx; i<n; i++{
            if sum+candidates[i]>target{
                break
            }
            //注意是i>idx，不需要额外用vis数组
            if i>idx&&candidates[i]==candidates[i-1]{
                continue
            }
            sum+=candidates[i]
            path=append(path, candidates[i])
            backtrack(i+1)
            path=path[:len(path)-1]
            sum-=candidates[i]
        }
        return 
    }
    backtrack(0)
    return ans
}
```
216. 组合总和 III
idx表示该path路径的下标需要进行选择, step表示1到9选择哪个数
```go
func combinationSum3(k int, n int) [][]int {
    ans:=make([][]int, 0)
    path:=make([]int, k)
    sum:=0
    var backtrack func(idx int, step int)
    backtrack=func(idx int, step int){
        if idx==k{
            if sum==n{
                t:=make([]int, len(path))
                copy(t, path)
                ans=append(ans, t)
            }
            return 
        }
        if sum>n{
            return 
        }
        for i:=step; i<=9; i++{
            if sum+i>n{
                break
            }
            sum+=i
            path[idx]=i
            backtrack(idx+1, i+1)
            //
            sum-=i
        }
    }
    backtrack(0, 1)
    return ans
}
```
216. 组合总和 IV是背包/爬楼梯问题
17. 电话号码的字母组合
```go
var alp []string = []string{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}

func letterCombinations(digits string) []string {
    n:=len(digits)
    ans:=make([]string, 0)
    if n==0{
        return ans
    }
    path:=make([]byte, n)
    var backtrack func(idx int)
    backtrack=func(idx int){
        if idx==n{
            t:=make([]byte, len(path))
            copy(t, path)
            ans=append(ans, string(t))
            return 
        }
        c:=digits[idx]
        str:=alp[int(c-'0')]
        for i:=0; i<len(str); i++{
            path[idx]=str[i]
            backtrack(idx+1)
            // path=path[:len(path)-1]
        }
        return 
    }
    backtrack(0)
    return ans
}
```
#### 子集
78. 子集
和组合有点像，都是从维护一个idx
```go
func subsets(nums []int) [][]int {
    n:=len(nums)
    ans:=make([][]int, 0)
    path:=make([]int, 0)
    var backtrack func(idx int)
    backtrack = func(idx int){
        t:=make([]int, len(path))
        copy(t, path)
        ans=append(ans, t)

        for i:=idx; i<n; i++{
            path=append(path, nums[i])
            backtrack(i+1)
            path=path[:len(path)-1]
        }
    }
    backtrack(0)
    return ans
}
```
90. 子集 II
```go
func subsetsWithDup(nums []int) [][]int {
    sort.Slice(nums, func(i, j int) bool{
        return nums[i]<nums[j]
    })
    n:=len(nums)
    ans:=make([][]int, 0)
    path:=make([]int, 0)
    var backtrack func(step int)
    backtrack=func(step int){
        t:=make([]int, len(path))
        copy(t, path)
        ans=append(ans, t)
        //
        for i:=step; i<n; i++{
	        //注意是i>step
            if i>step&&nums[i]==nums[i-1]{
                continue
            }
            path=append(path, nums[i])
            backtrack(i+1)
            path=path[:len(path)-1]
        }
    }
    backtrack(0)
    return ans
}
```
#### 分割问题
131. 分割回文串
```go
func partition(s string) [][]string {
    ans:=make([][]string, 0)
    path:=make([]string, 0)
    var backtrack func(str string)
    backtrack = func(str string){
        if len(str)==0{
            t:=make([]string, len(path))
            copy(t, path)
            ans=append(ans, t)
            return  
        }
        for i:=0; i<len(str); i++{
            if !isPali(str[:i+1]){
                continue
            }
            path=append(path, str[:i+1])
            backtrack(str[i+1:])
            path=path[:len(path)-1]
        }
    }
    backtrack(s)
    return ans
}

func isPali(str string) bool {
    for i:=0; i<len(str)/2; i++{
        if str[i]!=str[len(str)-1-i]{
            return false
        }
    }
    return true
}
```
#### 总结
子集排列组合，注意有重复元素时需要先排序