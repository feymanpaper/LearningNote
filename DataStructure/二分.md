#### 红蓝二分
https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/967331/lan-hong-hua-fen-fa-dan-mo-ban-miao-sha-e7r40/
主体思路：left 指针掌管左边蓝色区域， right 指针掌管右边红色区域，两者互不冲突，通过不断向目标元素靠近扩大掌管区域，直到两者掌管区域接壤，即 left+1\=\=right 时终止。
由于left的初始值为-1, 终止条件是left+1!=right, 因此right的区间范围为\[0,n\]
反之, right的初始值为n, 因此left的区间范围为\[-1,n-1\]
```go
func bisearch(nums []int, tar int) int{
    n:=len(nums)
    l,r:=-1,n
    for l+1!=r{
        mid:=l+(r-l)/2
        if tar>nums[mid]{
            l=mid
        }else{
            r=mid
        }
    }
    return r
}
```
#### 例题
##### 34.在排序数组中查找元素的第一个和最后一个位置
```go
func searchRange(nums []int, target int) []int {
    n:=len(nums)
    l:=-1
    r:=n
    for l+1!=r{
        mid:=l+(r-l)>>1
        if nums[mid]<=target{
            l=mid
        }else{
            r=mid
        }
    }
    ans1:=-1
    if l==-1||nums[l]!=target{
        ans1=-1
    }else{
        ans1=l
    }
    l=-1
    r=n
    for l+1!=r{
        mid:=l+(r-l)>>1
        if nums[mid]<target{
            l=mid
        }else{
            r=mid
        }
    }
    ans2:=n
    if r==n||nums[r]!=target{
        ans2=-1
    }else{
        ans2=r
    }
    return []int{ans2, ans1}
}
```
##### 162.寻找峰值
右边最后一个索引n-1是r的地盘
https://leetcode.cn/problems/find-peak-element/solutions/998441/gong-shui-san-xie-noxiang-xin-ke-xue-xi-qva7v/
```go
func findPeakElement(nums []int) int {
    n:=len(nums)
    l:=-1
    r:=n
    for l+1!=r{
        mid:=l+(r-l)>>1
        if mid<n-1&&nums[mid]<nums[mid+1]{
            l=mid
        }else{
            r=mid
        }
    }
    return r
}
```

81.搜索旋转排序数组 II
二维二分
74.搜索二维矩阵
两次二分
240.搜索二维矩阵 II
sol1:用右上角巧妙法来做
sol2:二维二分
```go
func searchMatrix(matrix [][]int, target int) bool {
    m:=len(matrix)
    n:=len(matrix[0])
    var search func(rs, re, cs, ce int) bool
    search = func(rs, re, cs, ce int) bool{
        if rs>re||cs>ce{
            return false
        }
	    //这个是必要的, 因为target<matrix[rowmid][colmid]时search(rs,rowmid,cs,colmid)没变化会爆内存
        if rs==re&&cs==ce{
            return target==matrix[rs][cs]
        }
        rowmid:=rs+(re-rs)>>1
        colmid:=cs+(ce-cs)>>1
        if target>matrix[rowmid][colmid]{
            return search(rs, rowmid, colmid+1, ce)||search(rowmid+1,re, cs,colmid)||search(rowmid+1,re,colmid+1,ce)
        }else if target<matrix[rowmid][colmid]{
            return search(rs,rowmid,cs,colmid)||search(rs, rowmid, colmid+1,ce)||search(rowmid+1,re,cs,colmid)
        }
        return true
    }
    return search(0, m-1, 0, n-1)
}
```