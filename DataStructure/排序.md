冒泡排序
```go
func bubbleSort(nums []int) []int {
    n:=len(nums)
    for i:=0; i<n-1; i++{
        flag:=false
        for j:=0; j<n-1-i; j++{
            if nums[j]>nums[j+1]{
                nums[j],nums[j+1]=nums[j+1],nums[j]
                flag=true
            }
        }
        if !flag{
            return nums
        }
    }
    return nums
}
```
选择排序 
```go
func selectSort(nums []int) []int {
    n:=len(nums)
    for i:=0; i<n-1; i++{
        midx:=i
        for j:=i+1; j<n; j++{
            if nums[j]<nums[midx]{
                midx=j
            }
        }
        nums[i],nums[midx]=nums[midx],nums[i]
    }
    return nums
}
```
插入排序
```go
func insertSort(nums []int) []int {
    n:=len(nums)
    for i:=1; i<n; i++{
        for j:=i; j>=1; j--{
            if nums[j]<nums[j-1]{
                nums[j],nums[j-1]=nums[j-1],nums[j]
            }else{
                break
            }
        }
    }
    return nums
}
```
快速排序
```go
func sortArray(nums []int) []int {
    //quickSort
    n:=len(nums)
    quickSort(nums, 0, n-1)
    return nums
}

func quickSort(nums []int, l, r int){
    if l>=r{
        return 
    }
    idx:=partition(nums, l, r)
    quickSort(nums, l, idx-1)
    quickSort(nums, idx+1, r)
}

func partition(nums []int, l, r int) int{
    mid:=l+(r-l)>>1
    nums[l],nums[mid]=nums[mid],nums[l]
    pivot:=nums[l]
    for l<r{
        for l<r&&nums[r]>=pivot{
            r--
        }
        nums[l]=nums[r]
        for l<r&&nums[l]<=pivot{
            l++
        }
        nums[r]=nums[l]
    }
    nums[l]=pivot
    return l
}
```
归并排序
```go
func sortArray(nums []int) []int {
    //quickSort
    mergeSort(nums, 0, len(nums)-1)
    return nums
}

func mergeSort(nums []int, l, r int){
    if l>=r{
        return 
    }
    mid:=l+(r-l)>>1
    mergeSort(nums, l, mid)
    mergeSort(nums, mid+1, r)
    merge(nums, l, mid, mid+1, r)
}

func merge(nums []int, l1, r1, l2, r2 int){
    n:= r1-l1+1+r2-l2+1
    temp:=make([]int, n)
    idx:=0
    p:=l1
    q:=l2
    for p<=r1||q<=r2{
        if p<=r1&&q<=r2{
            if nums[p]<nums[q]{
                temp[idx]=nums[p]
                idx++
                p++
            }else{
                temp[idx]=nums[q]
                idx++
                q++
            }
        }else if p<=r1{
            temp[idx]=nums[p]
            idx++
            p++
        }else{
            temp[idx]=nums[q]
            idx++
            q++
        }
    }
    for i:=0; i<n; i++{
        nums[l1+i]=temp[i]
    }
}

```
