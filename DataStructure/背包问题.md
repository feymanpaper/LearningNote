背包问题是「动态规划」中十分经典的一类问题，背包问题本质上属于组合优化的「 NP完全问题」。
你可以将「 完全问题」简单理解为「无法直接求解」的问题。
例如「分解质因数」问题，我们无法像四则运算（加减乘除）那样，按照特定的逻辑进行求解。
只能通过「穷举」+「验证」的方式进行求解。
既然本质上是一个无法避免「穷举」的问题，自然会联想到「动态规划」，事实上背包问题也同时满足「无后效性」的要求。
### 01背包
有 N件物品和一个容量是 V的背包。每件物品有且只有一件
第 i 件物品的体积是 v\[i]，价值是w\[i] 。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大
https://mp.weixin.qq.com/s/xmgK7SrTnFIM3Owpk-emmg
遍历方向为
当前状态取决于左边和左上, 可以从二维优化到一维
![](Pasted%20image%2020240212133121.png)

#### 416. 分割等和子集
dp\[i]\[j] = dp\[i-1]\[j] or dp\[i-1]\[j-nums\[i]]
表示前i个数字，能否刚好装满容量大小为j背包
```go
func canPartition(nums []int) bool {
    sum:=0
    n:=len(nums)
    for _,x:=range nums{
        sum+=x
    }
    if sum&1!=0{
        return false
    }
    target:=sum/2
    dp:=make([]bool, target+1)
    dp[0]=true
    for i:=1; i<n; i++{
        for j:=target; j>=nums[i]; j--{
            dp[j]=dp[j]||dp[j-nums[i]]
        }
    }
    return dp[target]
}
```