[
  {"id":"alrawiBetrayalCloudCity","abstract":"Cloud backends provide essential features to the mobile app ecosystem, such as content delivery, ad networks, analytics, and more. Unfortunately, app developers often disregard or have no control over prudent security practices when choosing or managing these services. Our preliminary study of the top 5,000 Google Play Store free apps identiﬁed 983 instances of N-day and 655 instances of 0-day vulnerabilities spanning across the software layers (OS, software services, communication, and web apps) of cloud backends. The mobile apps using these cloud backends represent between 1M and 500M installs each and can potentially affect hundreds of thousands of users. Further, due to the widespread use of third-party SDKs, app developers are often unaware of the backends affecting their apps and where to report vulnerabilities. This paper presents SkyWalker, a pipeline to automatically vet the backends that mobile apps contact and provide actionable remediation. For an input APK, SkyWalker extracts an enumeration of backend URLs, uses remote vetting techniques to identify software vulnerabilities and responsible parties, and reports mitigation strategies to the app developer. Our ﬁndings suggest that developers and cloud providers do not have a clear understanding of responsibilities and liabilities in regards to mobile app backends that leave many vulnerabilities exposed.","author":[{"family":"Alrawi","given":"Omar"},{"family":"Kasturi","given":"Ranjita Pai"},{"family":"Zuo","given":"Chaoshun"},{"family":"Lin","given":"Zhiqiang"},{"family":"Duan","given":"Ruian"},{"family":"Saltaformaggio","given":"Brendan"}],"citation-key":"alrawiBetrayalCloudCity","language":"en","source":"Zotero","title":"The Betrayal At Cloud City: An Empirical Analysis Of Cloud-Based Mobile Backends","type":"article-journal"},
  {"id":"amalfitanoMobiGUITARAutomatedModelBased2015","abstract":"As mobile devices become increasingly smarter and more powerful, so too must the engineering of their software. User-interface-driven system testing of these devices is gaining popularity, with each vendor releasing some automation tool. However, these tools are inappropriate for amateur programmers, an increasing portion of app developers. MobiGUITAR (Mobile GUI Testing Framework) provides automated GUI-driven testing of Android apps. It's based on observation, extraction, and abstraction of GUI widgets' run-time state. The abstraction is a scalable state machine model that, together with test coverage criteria, provides a way to automatically generate test cases. When applied to four open-source Android apps, MobiGUITAR automatically generated and executed 7,711 test cases and reported 10 new bugs. Some bugs were Android-specific, stemming from the event- and activity-driven nature of Android.","author":[{"family":"Amalfitano","given":"Domenico"},{"family":"Fasolino","given":"Anna Rita"},{"family":"Tramontana","given":"Porfirio"},{"family":"Ta","given":"Bryan Dzung"},{"family":"Memon","given":"Atif M."}],"citation-key":"amalfitanoMobiGUITARAutomatedModelBased2015","container-title":"IEEE Software","DOI":"10.1109/MS.2014.55","ISSN":"1937-4194","issue":"5","issued":{"date-parts":[["2015",9]]},"page":"53-59","source":"IEEE Xplore","title":"MobiGUITAR: Automated Model-Based Testing of Mobile Apps","title-short":"MobiGUITAR","type":"article-journal","volume":"32"},
  {"id":"amalfitanoUsingGUIRipping2012","abstract":"We present AndroidRipper, an automated technique that tests Android apps via their Graphical User Interface (GUI). AndroidRipper is based on a user-interface driven ripper that automatically explores the app’s GUI with the aim of exercising the application in a structured manner. We evaluate AndroidRipper on an open-source Android app. Our results show that our GUI-based test cases are able to detect severe, previously unknown, faults in the underlying code, and the structured exploration outperforms a random approach.","accessed":{"date-parts":[["2023",5,18]]},"author":[{"family":"Amalfitano","given":"Domenico"},{"family":"Fasolino","given":"Anna Rita"},{"family":"Tramontana","given":"Porfirio"},{"family":"De Carmine","given":"Salvatore"},{"family":"Memon","given":"Atif M."}],"citation-key":"amalfitanoUsingGUIRipping2012","container-title":"Proceedings of the 27th IEEE/ACM International Conference on Automated Software Engineering","DOI":"10.1145/2351676.2351717","event-place":"Essen Germany","event-title":"ASE'12: IEEE/ACM International Conference on Automated Software Engineering","ISBN":"978-1-4503-1204-2","issued":{"date-parts":[["2012",9,3]]},"language":"en","page":"258-261","publisher":"ACM","publisher-place":"Essen Germany","source":"DOI.org (Crossref)","title":"Using GUI ripping for automated testing of Android applications","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/2351676.2351717"},
  {"id":"azimTargetedDepthfirstExploration2013","accessed":{"date-parts":[["2023",6,4]]},"author":[{"family":"Azim","given":"Tanzirul"},{"family":"Neamtiu","given":"Iulian"}],"citation-key":"azimTargetedDepthfirstExploration2013","container-title":"Proceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages & applications","DOI":"10.1145/2509136.2509549","event-place":"Indianapolis Indiana USA","event-title":"SPLASH '13: Conference on Systems, Programming, and Applications: Software for Humanity","ISBN":"978-1-4503-2374-1","issued":{"date-parts":[["2013",10,29]]},"language":"en","page":"641-660","publisher":"ACM","publisher-place":"Indianapolis Indiana USA","source":"DOI.org (Crossref)","title":"Targeted and depth-first exploration for systematic testing of android apps","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/2509136.2509549"},
  {"id":"backesDemystifyingAndroidApplication","abstract":"In contrast to the Android application layer, Android’s application framework’s internals and their inﬂuence on the platform security and user privacy are still largely a black box for us. In this paper, we establish a static runtime model of the application framework in order to study its internals and provide the ﬁrst high-level classiﬁcation of the framework’s protected resources. We thereby uncover design patterns that diﬀer highly from the runtime model at the application layer. We demonstrate the beneﬁts of our insights for security-focused analysis of the framework by re-visiting the important use-case of mapping Android permissions to framework/SDK API methods. We, in particular, present a novel mapping based on our ﬁndings that signiﬁcantly improves on prior results in this area that were established based on insuﬃcient knowledge about the framework’s internals. Moreover, we introduce the concept of permission locality to show that although framework services follow the principle of separation of duty, the accompanying permission checks to guard sensitive operations violate it.","author":[{"family":"Backes","given":"Michael"},{"family":"Bugiel","given":"Sven"},{"family":"Derr","given":"Erik"},{"family":"McDaniel","given":"Patrick"},{"family":"Octeau","given":"Damien"},{"family":"Weisgerber","given":"Sebastian"}],"citation-key":"backesDemystifyingAndroidApplication","language":"en","source":"Zotero","title":"On Demystifying the Android Application Framework: Re-Visiting Android Permission Speciﬁcation Analysis","type":"article-journal"},
  {"id":"baekAutomatedModelbasedAndroid2016","abstract":"Automated Graphical User Interface (GUI) testing is one of the most widely used techniques to detect faults in mobile applications (apps) and to test functionality and usability. GUI testing exercises behaviors of an application under test (AUT) by executing events on GUIs and checking whether the app behaves correctly. In particular, because Android leads in market share of mobile OS platforms, a lot of research on automated Android GUI testing techniques has been performed. Among various techniques, we focus on model-based Android GUI testing that utilizes a GUI model for systematic test generation and effective debugging support. Since test inputs are generated based on the underlying model, accurate GUI modeling of an AUT is the most crucial factor in order to generate effective test inputs. However, most modern Android apps contain a number of dynamically constructed GUIs that make accurate behavior modeling more challenging. To address this problem, we propose a set of multi-level GUI Comparison Criteria (GUICC) that provides the selection of multiple abstraction levels for GUI model generation. By using multilevel GUICC, we conducted empirical experiments to identify the influence of GUICC on testing effectiveness. Results show that our approach, which performs model-based testing with multi-level GUICC, achieved higher effectiveness than activity-based GUI model generation. We also found that multi-level GUICC can alleviate the inherent state explosion problems of existing a single-level GUICC for behavior modeling of real-world Android apps by flexibly manipulating GUICC.","accessed":{"date-parts":[["2023",6,3]]},"author":[{"family":"Baek","given":"Young-Min"},{"family":"Bae","given":"Doo-Hwan"}],"citation-key":"baekAutomatedModelbasedAndroid2016","collection-title":"ASE '16","container-title":"Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering","DOI":"10.1145/2970276.2970313","event-place":"New York, NY, USA","ISBN":"978-1-4503-3845-5","issued":{"literal":"8 月 25, 2016"},"page":"238–249","publisher":"Association for Computing Machinery","publisher-place":"New York, NY, USA","source":"ACM Digital Library","title":"Automated model-based Android GUI testing using multi-level GUI comparison criteria","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/2970276.2970313"},
  {"id":"borgesjr.DroidMate2PlatformAndroid2018","accessed":{"date-parts":[["2023",6,2]]},"author":[{"family":"Borges Jr.","given":"Nataniel P."},{"family":"Hotzkow","given":"Jenny"},{"family":"Zeller","given":"Andreas"}],"citation-key":"borgesjr.DroidMate2PlatformAndroid2018","container-title":"Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering","DOI":"10.1145/3238147.3240479","event-place":"Montpellier France","event-title":"ASE '18: 33rd ACM/IEEE International Conference on Automated Software Engineering","ISBN":"978-1-4503-5937-5","issued":{"date-parts":[["2018",9,3]]},"language":"en","page":"916-919","publisher":"ACM","publisher-place":"Montpellier France","source":"DOI.org (Crossref)","title":"DroidMate-2: a platform for Android test generation","title-short":"DroidMate-2","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3238147.3240479"},
  {"id":"boseColumbusAndroidApp2023","abstract":"With the continuous rise in the popularity of Android mobile devices, automated testing of apps has become more important than ever. Android apps are event-driven programs. Unfortunately, generating all possible types of events by interacting with an app’s interface is challenging for an automated testing approach. Callback-driven testing eliminates the need for event generation by directly invoking app callbacks. However, existing callback-driven testing techniques assume prior knowledge of Android callbacks, and they rely on a human expert, who is familiar with the Android API, to write stub code that prepares callback arguments before invocation. Since the Android API is very large and keeps evolving, prior techniques could only support a small fraction of callbacks present in the Android framework.","accessed":{"date-parts":[["2023",6,2]]},"author":[{"family":"Bose","given":"Priyanka"},{"family":"Das","given":"Dipanjan"},{"family":"Vasan","given":"Saastha"},{"family":"Mariani","given":"Sebastiano"},{"family":"Grishchenko","given":"Ilya"},{"family":"Continella","given":"Andrea"},{"family":"Bianchi","given":"Antonio"},{"family":"Kruegel","given":"Christopher"},{"family":"Vigna","given":"Giovanni"}],"citation-key":"boseColumbusAndroidApp2023","issued":{"date-parts":[["2023",2,17]]},"language":"en","number":"arXiv:2302.09116","publisher":"arXiv","source":"arXiv.org","title":"Columbus: Android App Testing Through Systematic Callback Exploration","title-short":"Columbus","type":"article","URL":"http://arxiv.org/abs/2302.09116"},
  {"id":"boseSAILFISHVettingSmart2021","abstract":"This paper presents SAILFISH, a scalable system for automatically ﬁnding state-inconsistency bugs in smart contracts. To make the analysis tractable, we introduce a hybrid approach that includes (i) a light-weight exploration phase that dramatically reduces the number of instructions to analyze, and (ii) a precise reﬁnement phase based on symbolic evaluation guided by our novel value-summary analysis, which generates extra constraints to over-approximate the side effects of whole-program execution, thereby ensuring the precision of the symbolic evaluation. We developed a prototype of SAILFISH and evaluated its ability to detect two state-inconsistency ﬂaws, viz., reentrancy and transaction order dependence (TOD) in Ethereum smart contracts.","accessed":{"date-parts":[["2022",12,28]]},"author":[{"family":"Bose","given":"Priyanka"},{"family":"Das","given":"Dipanjan"},{"family":"Chen","given":"Yanju"},{"family":"Feng","given":"Yu"},{"family":"Kruegel","given":"Christopher"},{"family":"Vigna","given":"Giovanni"}],"citation-key":"boseSAILFISHVettingSmart2021","issued":{"date-parts":[["2021",12,12]]},"language":"en","number":"arXiv:2104.08638","publisher":"arXiv","source":"arXiv.org","title":"SAILFISH: Vetting Smart Contract State-Inconsistency Bugs in Seconds","title-short":"SAILFISH","type":"article","URL":"http://arxiv.org/abs/2104.08638"},
  {"id":"caiFastbotMultiAgentModelBased2020","abstract":"Model-based test (MBT) generation techniques for automated GUI testing are of great value for app testing. Existing GUI model-based testing tools may fall into cyclic operations and run out of resources, when applied to apps with industrial complexity and scalability. In this work, we present a multi-agent GUI MBT system named Fastbot. Fastbot performs model construction on the server end. It applies multi-agent collaboration mechanism to speed up the model construction procedure. The proposed approach was applied on more than 20 applications from Bytedance with more than 1500 million monthly active users. Higher code coverage in less testing time is achieved with comparison of three other automated testing tools including Droidbot, Humanoid and Android Monkey.","accessed":{"date-parts":[["2023",6,2]]},"author":[{"family":"Cai","given":"Tianqin"},{"family":"Zhang","given":"Zhao"},{"family":"Yang","given":"Ping"}],"citation-key":"caiFastbotMultiAgentModelBased2020","collection-title":"AST '20","container-title":"Proceedings of the IEEE/ACM 1st International Conference on Automation of Software Test","DOI":"10.1145/3387903.3389308","event-place":"New York, NY, USA","ISBN":"978-1-4503-7957-1","issued":{"literal":"10 月 7, 2020"},"page":"93–96","publisher":"Association for Computing Machinery","publisher-place":"New York, NY, USA","source":"ACM Digital Library","title":"Fastbot: A Multi-Agent Model-Based Test Generation System Beijing Bytedance Network Technology Co., Ltd.","title-short":"Fastbot","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3387903.3389308"},
  {"id":"caoLargeScaleStudy","abstract":"We conduct a global study on the behaviors, expectations and engagement of 1,719 participants across 10 countries and regions towards Android application permissions. Participants were recruited using mobile advertising and used an application we designed for 30 days. Our app samples user behaviors (decisions made), rationales (via in-situ surveys), expectations, and attitudes, as well as some app provided explanations. We study the grant and deny decisions our users make, and build mixed effect logistic regression models to illustrate the many factors that inﬂuence this decision making. Among several interesting ﬁndings, we observed that users facing an unexpected permission request are more than twice as likely to deny it compared to a user who expects it, and that permission requests accompanied by an explanation have a deny rate that is roughly half the deny rate of app permission requests without explanations. These ﬁndings remain true even when controlling for other factors. To the best of our knowledge, this may be the ﬁrst study of actual privacy behavior (not stated behavior) for Android apps, with users using their own devices, across multiple continents.","author":[{"family":"Cao","given":"Weicheng"},{"family":"Xia","given":"Chunqiu"},{"family":"Peddinti","given":"Sai Teja"},{"family":"Lie","given":"David"},{"family":"Taft","given":"Nina"},{"family":"Austin","given":"Lisa M"}],"citation-key":"caoLargeScaleStudy","language":"en","source":"Zotero","title":"A Large Scale Study of User Behavior, Expectations and Engagement with Android Permissions","type":"article-journal"},
  {"id":"chenExperimentalSecurityAnalysis","abstract":"Business Collaboration Platforms like Microsoft Teams and Slack enable teamwork by supporting text chatting and third-party resource integration. A user can access online ﬁle storage, make video calls, and manage a code repository, all from within the platform, thus making them a hub for sensitive communication and resources. The key enabler for these productivity features is a third-party application model. We contribute an experimental security analysis of this model and the third-party apps. Performing this analysis is challenging because commercial platforms and their apps are closed-source systems. Our analysis methodology is to systematically investigate different types of interactions possible between apps and users. We discover that the access control model in these systems violates two fundamental security principles: least privilege and complete mediation. These violations enable a malicious app to exploit the conﬁdentiality and integrity of user messages and third-party resources connected to the platform. We construct proof-of-concept attacks that can: (1) eavesdrop on user messages without having permission to read those messages; (2) launch fake video calls; (3) automatically merge code into repositories without user approval or involvement. Finally, we provide an analysis of countermeasures that systems like Slack and Microsoft Teams can adopt today.","author":[{"family":"Chen","given":"Yunang"},{"family":"Gao","given":"Yue"},{"family":"Ceccio","given":"Nick"},{"family":"Chatterjee","given":"Rahul"},{"family":"Fawaz","given":"Kassem"},{"family":"Fernandes","given":"Earlence"}],"citation-key":"chenExperimentalSecurityAnalysis","language":"en","source":"Zotero","title":"Experimental Security Analysis of the App Model in Business Collaboration Platforms","type":"article-journal"},
  {"id":"chenFindingUnknownMalice","abstract":"An app market’s vetting process is expected to be scalable and effective. However, today’s vetting mechanisms are slow and less capable of catching new threats. In our research, we found that a more powerful solution can be found by exploiting the way Android malware is constructed and disseminated, which is typically through repackaging legitimate apps with similar malicious components. As a result, such attack payloads often stand out from those of the same repackaging origin and also show up in the apps not supposed to relate to each other.","author":[{"family":"Chen","given":"Kai"},{"family":"Wang","given":"Peng"},{"family":"Lee","given":"Yeonjoon"},{"family":"Wang","given":"XiaoFeng"},{"family":"Zhang","given":"Nan"},{"family":"Huang","given":"Heqing"},{"family":"Zou","given":"Wei"},{"family":"Liu","given":"Peng"}],"citation-key":"chenFindingUnknownMalice","language":"en","source":"Zotero","title":"Finding Unknown Malice in 10 Seconds: Mass Vetting for New Threats at the Google-Play Scale","type":"article-journal"},
  {"id":"chenMetamorphicTestingNew","abstract":"In software testing, a set of test cases is constructed according to some prede ned selection criteria. The software is then examined against these test cases. Three interesting observations have been made on the current artifacts of software testing. Firstly, an error-revealing test case is considered useful while a successful test case which does not reveal software errors is usually not further investigated. Whether these successful test cases still contain useful information for revealing software errors has not been properly studied. Secondly, no matter how extensive the testing has been conducted in the development phase, errors may still exist in the software 5 . These errors, if left undetected, may eventually cause damage to the production system. The study of techniques for uncovering software errors in the production phase is seldom addressed in the literature. Thirdly, as indicated by Weyuker in 6 , the availability of test oracles is pragmatically unattainable in most situations. However, the availability of test oracles is generally assumed in conventional software testing techniques. In this paper, we propose a novel test case selection technique that derives new test cases from the successful ones. The selection aims at revealing software errors that are possibly left undetected in successful test cases which may be generated using some existing strategies. As such, the proposed technique augments the e ectiveness of existing test selection strategies. The yThis project was partially supported by a grant from the Australian Research Council and the Hong Kong Research Grant Council.","author":[{"family":"Chen","given":"T Y"}],"citation-key":"chenMetamorphicTestingNew","language":"en","source":"Zotero","title":"Metamorphic Testing: A New Approach for Generating Next Test Cases y","type":"article-journal"},
  {"id":"chinprutthiwongSecurityStudyService2020","abstract":"Nowadays, modern websites are utilizing service workers to provide users with app-like functionalities such as offline mode and push notifications. To handle such features, the service worker is equipped with special privileges including HTTP traffic manipulation. Thus, it is designed with security as a priority. However, we find that many websites introduce a questionable practice that can jeopardize the security of a service worker.","accessed":{"date-parts":[["2023",2,21]]},"author":[{"family":"Chinprutthiwong","given":"Phakpoom"},{"family":"Vardhan","given":"Raj"},{"family":"Yang","given":"GuangLiang"},{"family":"Gu","given":"Guofei"}],"citation-key":"chinprutthiwongSecurityStudyService2020","container-title":"Annual Computer Security Applications Conference","DOI":"10.1145/3427228.3427290","event-place":"Austin USA","event-title":"ACSAC '20: Annual Computer Security Applications Conference","ISBN":"978-1-4503-8858-0","issued":{"date-parts":[["2020",12,7]]},"language":"en","page":"643-654","publisher":"ACM","publisher-place":"Austin USA","source":"DOI.org (Crossref)","title":"Security Study of Service Worker Cross-Site Scripting.","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3427228.3427290"},
  {"id":"chinprutthiwongServiceWorkerHiding2021","abstract":"In recent years, service workers are gaining attention from both web developers and attackers due to the unique features they provide. Recent findings have shown that an attacker can register a malicious service worker to take advantage of the victim such as by turning the victim’s device into a crypto-currency miner. However, the possibility of benign service workers being leveraged is not well studied.","accessed":{"date-parts":[["2023",2,21]]},"author":[{"family":"Chinprutthiwong","given":"Phakpoom"},{"family":"Vardhan","given":"Raj"},{"family":"Yang","given":"GuangLiang"},{"family":"Zhang","given":"Yangyong"},{"family":"Gu","given":"Guofei"}],"citation-key":"chinprutthiwongServiceWorkerHiding2021","container-title":"24th International Symposium on Research in Attacks, Intrusions and Defenses","DOI":"10.1145/3471621.3471845","event-place":"San Sebastian Spain","event-title":"RAID '21: 24th International Symposium on Research in Attacks, Intrusions and Defenses","ISBN":"978-1-4503-9058-3","issued":{"date-parts":[["2021",10,6]]},"language":"en","page":"312-323","publisher":"ACM","publisher-place":"San Sebastian Spain","source":"DOI.org (Crossref)","title":"The Service Worker Hiding in Your Browser: The Next Web Attack Target?","title-short":"The Service Worker Hiding in Your Browser","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3471621.3471845"},
  {"id":"dengNAUTILUSAutomatedRESTful","abstract":"RESTful APIs have become arguably the most prevalent endpoint for accessing web services. Blackbox vulnerability scanners are a popular choice for detecting vulnerabilities in web services automatically. Unfortunately, they suffer from a number of limitations in RESTful API testing. Particularly, existing tools cannot effectively obtain the relations between API operations, and they lack the awareness of the correct sequence of API operations during testing. These drawbacks hinder the tools from requesting the API operations properly to detect potential vulnerabilities.","author":[{"family":"Deng","given":"Gelei"},{"family":"Zhang","given":"Zhiyi"},{"family":"Li","given":"Yuekang"},{"family":"Liu","given":"Yi"},{"family":"Zhang","given":"Tianwei"},{"family":"Liu","given":"Yang"},{"family":"Yu","given":"Guo"},{"family":"Wang","given":"Dongjin"}],"citation-key":"dengNAUTILUSAutomatedRESTful","language":"en","source":"Zotero","title":"NAUTILUS: Automated RESTful API Vulnerability Detection","type":"article-journal"},
  {"id":"DetectingStateInconsistency2023","citation-key":"DetectingStateInconsistency2023","issued":{"date-parts":[["2023"]]},"language":"en","source":"Zotero","title":"Detecting State Inconsistency Bugs in DApps  via On-Chain Transaction Replay and Fuzzing","type":"article-journal"},
  {"id":"dongTimetravelTestingAndroid2020","abstract":"Android testing tools generate sequences of input events to exercise the state space of the app-under-test. Existing search-based techniques systematically evolve a population of event sequences so as to achieve certain objectives such as maximal code coverage. The hope is that the mutation of fit event sequences leads to the generation of even fitter sequences. However, the evolution of event sequences may be ineffective. Our key insight is that pertinent app states which contributed to the original sequence's fitness may not be reached by a mutated event sequence. The original path through the state space is truncated at the point of mutation. In this paper, we propose instead to evolve a population of states which can be captured upon discovery and resumed when needed. The hope is that generating events on a fit program state leads to the transition to even fitter states. For instance, we can quickly deprioritize testing the main screen state which is visited by most event sequences, and instead focus our limited resources on testing more interesting states that are otherwise difficult to reach. We call our approach time-travel testing because of this ability to travel back to any state that has been observed in the past. We implemented time-travel testing into TimeMachine, a time-travel enabled version of the successful, automated Android testing tool Monkey. In our experiments on a large number of open- and closed source Android apps, TimeMachine outperforms the state-of-the-art search-based/model-based Android testing tools Sapienz and Stoat, both in terms of coverage achieved and crashes found. We call our approach time-travel testing because of this ability to travel back to any state that has been observed in the past. We implemented time-travel testing into TimeMachine, a time-travel enabled version of the successful, automated Android testing tool Monkey. In our experiments on a large number of open- and closed source Android apps, TimeMachine outperforms the state-of-the-art search-based/model-based Android testing tools Sapienz and Stoat, both in terms of coverage achieved and crashes found.","author":[{"family":"Dong","given":"Zhen"},{"family":"Böhme","given":"Marcel"},{"family":"Cojocaru","given":"Lucia"},{"family":"Roychoudhury","given":"Abhik"}],"citation-key":"dongTimetravelTestingAndroid2020","container-title":"2020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)","event-title":"2020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)","ISSN":"1558-1225","issued":{"date-parts":[["2020",10]]},"page":"481-492","source":"IEEE Xplore","title":"Time-travel Testing of Android Apps","type":"paper-conference"},
  {"id":"dongTimetravelTestingAndroid2020a","abstract":"Android testing tools generate sequences of input events to exercise the state space of the app-under-test. Existing search-based techniques systematically evolve a population of event sequences so as to achieve certain objectives such as maximal code coverage. The hope is that the mutation of fit event sequences leads to the generation of even fitter sequences. However, the evolution of event sequences may be ineffective. Our key insight is that pertinent app states which contributed to the original sequence's fitness may not be reached by a mutated event sequence. The original path through the state space is truncated at the point of mutation. In this paper, we propose instead to evolve a population of states which can be captured upon discovery and resumed when needed. The hope is that generating events on a fit program state leads to the transition to even fitter states. For instance, we can quickly deprioritize testing the main screen state which is visited by most event sequences, and instead focus our limited resources on testing more interesting states that are otherwise difficult to reach. We call our approach time-travel testing because of this ability to travel back to any state that has been observed in the past. We implemented time-travel testing into TimeMachine, a time-travel enabled version of the successful, automated Android testing tool Monkey. In our experiments on a large number of open- and closed source Android apps, TimeMachine outperforms the state-of-the-art search-based/model-based Android testing tools Sapienz and Stoat, both in terms of coverage achieved and crashes found.","accessed":{"date-parts":[["2023",6,1]]},"author":[{"family":"Dong","given":"Zhen"},{"family":"Böhme","given":"Marcel"},{"family":"Cojocaru","given":"Lucia"},{"family":"Roychoudhury","given":"Abhik"}],"citation-key":"dongTimetravelTestingAndroid2020a","collection-title":"ICSE '20","container-title":"Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering","DOI":"10.1145/3377811.3380402","event-place":"New York, NY, USA","ISBN":"978-1-4503-7121-6","issued":{"literal":"10 月 1, 2020"},"page":"481–492","publisher":"Association for Computing Machinery","publisher-place":"New York, NY, USA","source":"ACM Digital Library","title":"Time-travel testing of Android apps","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3377811.3380402"},
  {"id":"drakonakisPleaseForgetWhere2019","abstract":"The exposure of location data constitutes a significant privacy risk to users as it can lead to de-anonymization, the inference of sensitive information, and even physical threats. In this paper we present LPAuditor, a tool that conducts a comprehensive evaluation of the privacy loss caused by public location metadata. First, we demonstrate how our system can pinpoint users’ key locations at an unprecedented granularity by identifying their actual postal addresses. Our evaluation on Twitter data highlights the effectiveness of our techniques which outperform prior approaches by 18.9%-91.6% for homes and 8.7%-21.8% for workplaces. Next we present a novel exploration of automated private information inference that uncovers “sensitive” locations that users have visited (pertaining to health, religion, and sex/nightlife). We ﬁnd that location metadata can provide additional context to tweets and thus lead to the exposure of private information that might not match the users’ intentions.","accessed":{"date-parts":[["2022",12,27]]},"author":[{"family":"Drakonakis","given":"Kostas"},{"family":"Ilia","given":"Panagiotis"},{"family":"Ioannidis","given":"Sotiris"},{"family":"Polakis","given":"Jason"}],"citation-key":"drakonakisPleaseForgetWhere2019","container-title":"Proceedings 2019 Network and Distributed System Security Symposium","DOI":"10.14722/ndss.2019.23151","event-place":"San Diego, CA","event-title":"Network and Distributed System Security Symposium","ISBN":"978-1-891562-55-6","issued":{"date-parts":[["2019"]]},"language":"en","publisher":"Internet Society","publisher-place":"San Diego, CA","source":"DOI.org (Crossref)","title":"Please Forget Where I Was Last Summer: The Privacy Risks of Public Location (Meta)Data","title-short":"Please Forget Where I Was Last Summer","type":"paper-conference","URL":"https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_01A-6_Drakonakis_paper.pdf"},
  {"id":"fratantonioTriggerScopeDetectingLogic2016","abstract":"Android is the most popular mobile platform today, and it is also the mobile operating system that is most heavily targeted by malware. Existing static analyses are effective in detecting the presence of most malicious code and unwanted information flows. However, certain types of malice are very difficult to capture explicitly by modeling permission sets, suspicious API calls, or unwanted information flows. One important type of such malice is malicious application logic, where a program (often subtly) modifies its outputs or performs actions that violate the expectations of the user. Malicious application logic is very hard to identify without a specification of the \"normal,\" expected functionality of the application. We refer to malicious application logic that is executed, or triggered, only under certain (often narrow) circumstances as a logic bomb. This is a powerful mechanism that is commonly employed by targeted malware, often used as part of APTs and state-sponsored attacks: in fact, in this scenario, the malware is designed to target specific victims and to only activate under certain circumstances. In this paper, we make a first step towards detecting logic bombs. In particular, we propose trigger analysis, a new static analysis technique that seeks to automatically identify triggers in Android applications. Our analysis combines symbolic execution, path predicate reconstruction and minimization, and inter-procedural control-dependency analysis to enable the precise detection and characterization of triggers, and it overcomes several limitations of existing approaches. We implemented a prototype of our analysis, called TriggerScope, and we evaluated it over a large corpus of 9,582 benign apps from the Google Play Store and a set of trigger-based malware, including the recently-discovered HackingTeam's RCSAndroid advanced malware. Our system is capable of automatically identify several interesting time-, location-, and SMS-related triggers, is affected by a low false positive rate (0.38%), and it achieves 100% detection rate on the malware set. We also show how existing approaches, specifically when tasked to detect logic bombs, are affected by either a very high false positive rate or false negative rate. Finally, we discuss the logic bombs identified by our analysis, including two previously-unknown backdoors in benign apps.","author":[{"family":"Fratantonio","given":"Yanick"},{"family":"Bianchi","given":"Antonio"},{"family":"Robertson","given":"William"},{"family":"Kirda","given":"Engin"},{"family":"Kruegel","given":"Christopher"},{"family":"Vigna","given":"Giovanni"}],"citation-key":"fratantonioTriggerScopeDetectingLogic2016","container-title":"2016 IEEE Symposium on Security and Privacy (SP)","DOI":"10.1109/SP.2016.30","event-title":"2016 IEEE Symposium on Security and Privacy (SP)","ISSN":"2375-1207","issued":{"date-parts":[["2016",5]]},"page":"377-396","source":"IEEE Xplore","title":"TriggerScope: Towards Detecting Logic Bombs in Android Applications","title-short":"TriggerScope","type":"paper-conference"},
  {"id":"georgievBreakingFixingOriginBased2014","abstract":"Hybrid mobile applications (apps) combine the features of Web applications and “native” mobile apps. Like Web applications, they are implemented in portable, platformindependent languages such as HTML and JavaScript. Like native apps, they have direct access to local device resources—ﬁle system, location, camera, contacts, etc.","accessed":{"date-parts":[["2023",2,21]]},"author":[{"family":"Georgiev","given":"Martin"},{"family":"Jana","given":"Suman"},{"family":"Shmatikov","given":"Vitaly"}],"citation-key":"georgievBreakingFixingOriginBased2014","container-title":"Proceedings 2014 Network and Distributed System Security Symposium","DOI":"10.14722/ndss.2014.23323","event-place":"San Diego, CA","event-title":"Network and Distributed System Security Symposium","ISBN":"978-1-891562-35-8","issued":{"date-parts":[["2014"]]},"language":"en","publisher":"Internet Society","publisher-place":"San Diego, CA","source":"DOI.org (Crossref)","title":"Breaking and Fixing Origin-Based Access Control in Hybrid Web/Mobile Application Frameworks","type":"paper-conference","URL":"https://www.ndss-symposium.org/ndss2014/programme/breaking-and-fixing-origin-based-access-control-hybrid-webmobile-application-frameworks/"},
  {"id":"guoImprovingAutomatedGUI2020","abstract":"Exploring GUIs of Android apps plays a key role in many important scenarios such as functional testing (e.g., finding crash errors), security analysis (e.g., identifying malicious behav-iors) and competitive analysis (e.g., storyboarding app features). To automate GUI exploration, existing techniques often try to visit as many GUI pages as possible via specific strategies, e.g., random (like Monkey) or heuristic (like Stoat, A3E). However, their effectiveness is still unclear and much under-explored. To this end, we conducted the first study in this paper to understand and characterize their limitations by carefully analyzing the coverage reports from a set of real-world, open-source apps. Through this study, we identified three key limitations due to the lack of dependency knowledge during exploration, i.e., widget-page dependency, widget-widget dependency and system-event dependency. To overcome them, we introduce dependency-informed exploration, an automated approach that leverages static dependency analysis to effectively improve GUI exploration performance. Given an app, our approach first constructs a GUI page transition model that captures the dependencies between GUI widgets, and then guides GUI exploration during a depth-first traversal. We realized our approach as a tool named Gesda, and evaluated it on 70 open-source Android apps. The results show Gesda outperforms existing state-of-the-art GUI exploration techniques, i.e., Monkey and Stoat. Additionally, Gesda uncovers 4 previously unknown crashes in 4 apps as a by-product of GUI exploration due to the benefit of dependency knowledge, while Monkey and Stoat have not discovered them.","author":[{"family":"Guo","given":"Wunan"},{"family":"Shen","given":"Liwei"},{"family":"Su","given":"Ting"},{"family":"Peng","given":"Xin"},{"family":"Xie","given":"Weiyang"}],"citation-key":"guoImprovingAutomatedGUI2020","container-title":"2020 IEEE International Conference on Software Maintenance and Evolution (ICSME)","DOI":"10.1109/ICSME46990.2020.00059","event-title":"2020 IEEE International Conference on Software Maintenance and Evolution (ICSME)","ISSN":"2576-3148","issued":{"date-parts":[["2020",9]]},"page":"557-568","source":"IEEE Xplore","title":"Improving Automated GUI Exploration of Android Apps via Static Dependency Analysis","type":"paper-conference"},
  {"id":"guPracticalGUITesting2019","abstract":"This paper introduces a new, fully automated modelbased approach for effective testing of Android apps. Different from existing model-based approaches that guide testing with a static GUI model (i.e., the model does not evolve its abstraction during testing, and is thus often imprecise), our approach dynamically optimizes the model by leveraging the runtime information during testing. This capability of model evolution significantly improves model precision, and thus dramatically enhances the testing effectiveness compared to existing approaches, which our evaluation confirms.We have realized our technique in a practical tool, APE. On 15 large, widely-used apps from the Google Play Store, APE outperforms the state-of-the-art Android GUI testing tools in terms of both testing coverage and the number of detected unique crashes. To further demonstrate APE's effectiveness and usability, we conduct another evaluation of APE on 1,316 popular apps, where it found 537 unique crashes. Out of the 38 reported crashes, 13 have been fixed and 5 have been confirmed.","author":[{"family":"Gu","given":"Tianxiao"},{"family":"Sun","given":"Chengnian"},{"family":"Ma","given":"Xiaoxing"},{"family":"Cao","given":"Chun"},{"family":"Xu","given":"Chang"},{"family":"Yao","given":"Yuan"},{"family":"Zhang","given":"Qirun"},{"family":"Lu","given":"Jian"},{"family":"Su","given":"Zhendong"}],"citation-key":"guPracticalGUITesting2019","container-title":"2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)","DOI":"10.1109/ICSE.2019.00042","event-title":"2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)","ISSN":"1558-1225","issued":{"date-parts":[["2019",5]]},"page":"269-280","source":"IEEE Xplore","title":"Practical GUI Testing of Android Applications Via Model Abstraction and Refinement","type":"paper-conference"},
  {"id":"haoPUMAProgrammableUIautomation2014","abstract":"Mobile app ecosystems have experienced tremendous growth in the last six years. This has triggered research on dynamic analysis of performance, security, and correctness properties of the mobile apps in the ecosystem. Exploration of app execution using automated UI actions has emerged as an important tool for this research. However, existing research has largely developed analysis-specific UI automation techniques, wherein the logic for exploring app execution is intertwined with the logic for analyzing app properties. PUMA is a programmable framework that separates these two concerns. It contains a generic UI automation capability (often called a Monkey) that exposes high-level events for which users can define handlers. These handlers can flexibly direct the Monkey's exploration, and also specify app instrumentation for collecting dynamic state information or for triggering changes in the environment during app execution. Targeted towards operators of app marketplaces, PUMA incorporates mechanisms for scaling dynamic analysis to thousands of apps. We demonstrate the capabilities of PUMA by analyzing seven distinct performance, security, and correctness properties for 3,600 apps downloaded from the Google Play store.","accessed":{"date-parts":[["2023",6,3]]},"author":[{"family":"Hao","given":"Shuai"},{"family":"Liu","given":"Bin"},{"family":"Nath","given":"Suman"},{"family":"Halfond","given":"William G.J."},{"family":"Govindan","given":"Ramesh"}],"citation-key":"haoPUMAProgrammableUIautomation2014","collection-title":"MobiSys '14","container-title":"Proceedings of the 12th annual international conference on Mobile systems, applications, and services","DOI":"10.1145/2594368.2594390","event-place":"New York, NY, USA","ISBN":"978-1-4503-2793-0","issued":{"literal":"6 月 2, 2014"},"page":"204–217","publisher":"Association for Computing Machinery","publisher-place":"New York, NY, USA","source":"ACM Digital Library","title":"PUMA: programmable UI-automation for large-scale dynamic analysis of mobile apps","title-short":"PUMA","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/2594368.2594390"},
  {"id":"huangSUPORPreciseScalable","abstract":"While smartphones and mobile apps have been an essential part of our lives, privacy is a serious concern. Previous mobile privacy related research efforts have largely focused on predeﬁned known sources managed by smartphones. Sensitive user inputs through UI (User Interface), another information source that may contain a lot of sensitive information, have been mostly neglected.","author":[{"family":"Huang","given":"Jianjun"},{"family":"Li","given":"Zhichun"},{"family":"Xiao","given":"Xusheng"},{"family":"Wu","given":"Zhenyu"},{"family":"Lu","given":"Kangjie"},{"family":"Zhang","given":"Xiangyu"},{"family":"Jiang","given":"Guofei"}],"citation-key":"huangSUPORPreciseScalable","language":"en","source":"Zotero","title":"SUPOR: Precise and Scalable Sensitive User Input Detection  for Android Apps","type":"article-journal"},
  {"id":"huOTestWebViewOrientedTesting2023","abstract":"WebView is a UI widget that helps integrate web applications into the native context of Android apps. It provides powerful mechanisms for bi-directional interactions between the native-end (Java) and the web-end (JavaScript) of an Android app. However, these interaction mechanisms are complicated and have induced various types of bugs. To mitigate the problem, various techniques have been proposed to detect WebView-induced bugs via dynamic analysis, which heavily relies on executing tests to explore WebView behaviors. Unfortunately, these techniques either require manual effort or adopt random test generation approaches, which are not able to effectively explore diverse WebView behaviors. In this paper, we study the problem of test generation for WebViews in Android apps. Effective test generation for WebViews requires identifying the essential program properties to be covered by the generated tests. To this end, we propose WebView-specific properties to characterize WebView behaviors, and devise a cross-language dynamic analysis method to identify these properties. We develop ωTest, a test generation technique that searches for event sequences covering the identified WebView-specific properties. An evaluation on 74 real-world open-/closed-source Android apps shows that ωTest can cover diverse WebView behaviors and detect WebView-induced bugs effectively. ωTest detected 36 previously-unknown bugs. From the 22 bugs that we have reported to the app developers, 13 bugs were confirmed, 9 of which were fixed.","accessed":{"date-parts":[["2023",9,19]]},"author":[{"family":"Hu","given":"Jiajun"},{"family":"Wei","given":"Lili"},{"family":"Liu","given":"Yepang"},{"family":"Cheung","given":"Shing-Chi"}],"citation-key":"huOTestWebViewOrientedTesting2023","collection-title":"ISSTA 2023","container-title":"Proceedings of the 32nd ACM SIGSOFT International Symposium on Software Testing and Analysis","DOI":"10.1145/3597926.3598112","event-place":"New York, NY, USA","ISBN":"9798400702211","issued":{"literal":"7 月 13, 2023"},"page":"992–1004","publisher":"Association for Computing Machinery","publisher-place":"New York, NY, USA","source":"ACM Digital Library","title":"ωTest: WebView-Oriented Testing for Android Applications","title-short":"ωTest","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3597926.3598112"},
  {"id":"iannilloChizpurfleGrayBoxAndroid2017","abstract":"Android has become the most popular mobile OS, as it enables device manufacturers to introduce customizations to compete with value-added services. However, customizations make the OS less dependable and secure, since they can introduce software ﬂaws. Such ﬂaws can be found by using fuzzing, a popular testing technique among security researchers.","accessed":{"date-parts":[["2023",2,4]]},"author":[{"family":"Iannillo","given":"Antonio Ken"},{"family":"Natella","given":"Roberto"},{"family":"Cotroneo","given":"Domenico"},{"family":"Nita-Rotaru","given":"Cristina"}],"citation-key":"iannilloChizpurfleGrayBoxAndroid2017","container-title":"2017 IEEE 28th International Symposium on Software Reliability Engineering (ISSRE)","DOI":"10.1109/ISSRE.2017.16","event-place":"Toulouse","event-title":"2017 IEEE 28th International Symposium on Software Reliability Engineering (ISSRE)","ISBN":"978-1-5386-0941-5","issued":{"date-parts":[["2017",10]]},"language":"en","page":"1-11","publisher":"IEEE","publisher-place":"Toulouse","source":"DOI.org (Crossref)","title":"Chizpurfle: A Gray-Box Android Fuzzer for Vendor Service Customizations","title-short":"Chizpurfle","type":"paper-conference","URL":"http://ieeexplore.ieee.org/document/8109068/"},
  {"id":"jangPosterKerberoidPractical2019","abstract":"Decompilation is frequently used to analyze binary programs. In Android, however, decompilers all perform differently with varying apps due to their own characteristics. Obviously, there is no universal solution in all conditions. Based on this observation, we present a practical Android app decompilation system (called Kerberoid) that automatically stitches the results from multiple decompilers together to maximize the coverage and the accuracy of decompiled codes. We evaluate the performance of Kerberoid with 151 Android apps in which their corresponding source codes are publicly available. Kerberoid fully recovered all functions for 17% of the apps tested and gained a similarity score over 50% for 40% of the apps tested, increased by 7% and 9%, respectively, compared with the best existing decompiler.","author":[{"family":"Jang","given":"Heejun"},{"family":"Jin","given":"Beomjin"},{"family":"Hyun","given":"Sangwon"},{"family":"Kim","given":"Hyoungshick"}],"citation-key":"jangPosterKerberoidPractical2019","issued":{"date-parts":[["2019"]]},"language":"en","source":"Zotero","title":"Poster: Kerberoid: A Practical Android App Decompilation System with Multiple Decompilers","type":"article-journal"},
  {"id":"kochOKNotEnough","abstract":"Mobile applications leaking personal information is a well established observation pre and post GDPR. The legal requirements for personal data collection in the context of tracking are specified by GDPR and the common understanding is, that tracking must be based on proper consent. Studies of the consent dialogs on websites revealed severe issues including dark patterns. However, the mobile space is currently underexplored with initial observations pointing towards a similar state of affairs. To address this research gap we analyze a subset of possible consent dialogs, namely privacy consent dialogs, in 3006 Android and 1773 iOS applications. We show that 22.3% of all apps have any form of dialog with only 11.9% giving the user some form of actionable choice, e.g., at least an accept button. However, this choice is limited as a large proportion of all such dialogs employ some form of dark pattern coercing the user to consent.","author":[{"family":"Koch","given":"Simon"},{"family":"Altpeter","given":"Benjamin"},{"family":"Johns","given":"Martin"}],"citation-key":"kochOKNotEnough","language":"en","source":"Zotero","title":"The OK Is Not Enough: A Large Scale Study of Consent Dialogs in Smartphone Applications","type":"article-journal"},
  {"id":"laiGoalDrivenExplorationAndroid2019","abstract":"This paper proposes a solution for automated goaldriven exploration of Android applications – a scenario in which a user, e.g., a security auditor, needs to dynamically trigger the functionality of interest in an application, e.g., to check whether user-sensitive info is only sent to recognized third-party servers. As the auditor might need to check hundreds or even thousands of apps, manually exploring each app to trigger the desired behavior is too time-consuming to be feasible. Existing automated application exploration and testing techniques are of limited help in this scenario as well, as their goal is mostly to identify faults by systematically exploring different app paths, rather than swiftly navigating to the target functionality.","accessed":{"date-parts":[["2023",6,4]]},"author":[{"family":"Lai","given":"Duling"},{"family":"Rubin","given":"Julia"}],"citation-key":"laiGoalDrivenExplorationAndroid2019","container-title":"2019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)","DOI":"10.1109/ASE.2019.00021","event-place":"San Diego, CA, USA","event-title":"2019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)","ISBN":"978-1-72812-508-4","issued":{"date-parts":[["2019",11]]},"language":"en","page":"115-127","publisher":"IEEE","publisher-place":"San Diego, CA, USA","source":"DOI.org (Crossref)","title":"Goal-Driven Exploration for Android Applications","type":"paper-conference","URL":"https://ieeexplore.ieee.org/document/8952363/"},
  {"id":"leiInsecuritySMSOneTime2021","abstract":"SMS messages containing One-Time Passwords (OTPs) are a widely used mechanism for performing authentication in mobile applications. In fact, many popular apps use OTPs received via SMS as the only authentication factor, entirely replacing password-based authentication schemes. Although SMS OTP authentication mechanisms provide significant convenience to end-users, they also have significant security implications. In this paper, we study these mobile apps’ authentication schemes based on SMS OTPs, and, in particular, we perform a systematic study on the threats posed by “local attacks,” a scenario in which an attacker has control over an unprivileged third-party app on the victim’s device. This study was carried out using a combination of reverse engineering, formal verification, user studies, and large-scale automated analysis. Our work not only revealed vulnerabilities in third-party apps, but it also uncovered several new design and implementation flaws in core APIs implemented by the mobile operating systems themselves. For instance, we found two official Android APIs to be vulnerable by design, i.e., APIs that inevitably lead to the implementation of insecure authentication schemes, even when used according to their documentation. Moreover, we found that other APIs are prone to be used unsafely by apps’ developers.","accessed":{"date-parts":[["2022",12,27]]},"author":[{"family":"Lei","given":"Zeyu"},{"family":"Nan","given":"Yuhong"},{"family":"Fratantonio","given":"Yanick"},{"family":"Bianchi","given":"Antonio"}],"citation-key":"leiInsecuritySMSOneTime2021","container-title":"Proceedings 2021 Network and Distributed System Security Symposium","DOI":"10.14722/ndss.2021.24212","event-place":"Virtual","event-title":"Network and Distributed System Security Symposium","ISBN":"978-1-891562-66-2","issued":{"date-parts":[["2021"]]},"language":"en","publisher":"Internet Society","publisher-place":"Virtual","source":"DOI.org (Crossref)","title":"On the Insecurity of SMS One-Time Password Messages against Local Attackers in Modern Mobile Devices","type":"paper-conference","URL":"https://www.ndss-symposium.org/wp-content/uploads/ndss2021_3B-4_24212_paper.pdf"},
  {"id":"liCollectResponsiblyDeliver2022","accessed":{"date-parts":[["2023",2,21]]},"author":[{"family":"Li","given":"Shuai"},{"family":"Yang","given":"Zhemin"},{"family":"Hua","given":"Nan"},{"family":"Liu","given":"Peng"},{"family":"Zhang","given":"Xiaohan"},{"family":"Yang","given":"Guangliang"},{"family":"Yang","given":"Min"}],"citation-key":"liCollectResponsiblyDeliver2022","container-title":"Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security","DOI":"10.1145/3548606.3559371","event-place":"Los Angeles CA USA","event-title":"CCS '22: 2022 ACM SIGSAC Conference on Computer and Communications Security","ISBN":"978-1-4503-9450-5","issued":{"date-parts":[["2022",11,7]]},"language":"en","page":"1887-1900","publisher":"ACM","publisher-place":"Los Angeles CA USA","source":"DOI.org (Crossref)","title":"Collect Responsibly But Deliver Arbitrarily?: A Study on Cross-User Privacy Leakage in Mobile Apps","title-short":"Collect Responsibly But Deliver Arbitrarily?","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3548606.3559371"},
  {"id":"liuChattingGPT3ZeroShot2023","abstract":"Mobile apps are indispensable for people's daily life, and automated GUI (Graphical User Interface) testing is widely used for app quality assurance. There is a growing interest in using learning-based techniques for automated GUI testing which aims at generating human-like actions and interactions. However, the limitations such as low testing coverage, weak generalization, and heavy reliance on training data, make an urgent need for a more effective approach to generate human-like actions to thoroughly test mobile apps. Inspired by the success of the Large Language Model (LLM), e.g., GPT-3 and ChatGPT, in natural language understanding and question answering, we formulate the mobile GUI testing problem as a Q&A task. We propose GPTDroid, asking LLM to chat with the mobile apps by passing the GUI page information to LLM to elicit testing scripts, and executing them to keep passing the app feedback to LLM, iterating the whole process. Within it, we extract the static context of the GUI page and the dynamic context of the iterative testing process, design prompts for inputting this information to LLM, and develop a neural matching network to decode the LLM's output into actionable steps to execute the app. We evaluate GPTDroid on 86 apps from Google Play, and its activity coverage is 71%, with 32% higher than the best baseline, and can detect 36% more bugs with faster speed than the best baseline. GPTDroid also detects 48 new bugs on the Google Play with 25 of them being confirmed/fixed. We further summarize the capabilities of GPTDroid behind the superior performance, including semantic text input, compound action, long meaningful test trace, and test case prioritization.","accessed":{"date-parts":[["2023",5,22]]},"author":[{"family":"Liu","given":"Zhe"},{"family":"Chen","given":"Chunyang"},{"family":"Wang","given":"Junjie"},{"family":"Chen","given":"Mengzhuo"},{"family":"Wu","given":"Boyu"},{"family":"Che","given":"Xing"},{"family":"Wang","given":"Dandan"},{"family":"Wang","given":"Qing"}],"citation-key":"liuChattingGPT3ZeroShot2023","issued":{"date-parts":[["2023",5,16]]},"number":"arXiv:2305.09434","publisher":"arXiv","source":"arXiv.org","title":"Chatting with GPT-3 for Zero-Shot Human-Like Mobile Automated GUI Testing","type":"article","URL":"http://arxiv.org/abs/2305.09434"},
  {"id":"liUnleashingWalkingDead2017","abstract":"As a critical feature for enhancing user experience, cross-app URL invocation has been reported to cause unauthorized execution of app components. Although protection has already been put in place, little has been done to understand the security risks of navigating an app’s WebView through an URL, a legitimate need for displaying the app’s UI during cross-app interactions. In our research, we found that the current design of such cross-WebView navigation actually opens the door to a cross-app remote infection, allowing a remote adversary to spread malicious web content across different apps’ WebView instances and acquire stealthy and persistent control of these apps. This new threat, dubbed Cross-App WebView Infection (XAWI), enables a series of multi-app, colluding attacks never thought before, with significant real world impacts. Particularly, we found that the remote adversary can collectively utilize multiple infected apps’ individual capabilities to escalate his privileges on a mobile device or orchestrate a highly realistic remote Phishing attack (e.g., running a malicious script in Chrome to stealthily change Twitter’s WebView to fake Twitter’s own login UI). We show that the adversary can easily find such attack “building blocks” (popular apps whose WebViews can be redirected by another app) through an automatic fuzz, and discovered about 7.4% of the most popular apps subject to the XAWI attacks, including Facebook, Twitter, Amazon and others. Our study reveals the contention between the demand for convenient cross-WebView communication and the need for security control on the channel, and makes the first step toward building OS-level protection to safeguard this fast-growing technology.","accessed":{"date-parts":[["2022",12,27]]},"author":[{"family":"Li","given":"Tongxin"},{"family":"Wang","given":"Xueqiang"},{"family":"Zha","given":"Mingming"},{"family":"Chen","given":"Kai"},{"family":"Wang","given":"XiaoFeng"},{"family":"Xing","given":"Luyi"},{"family":"Bai","given":"Xiaolong"},{"family":"Zhang","given":"Nan"},{"family":"Han","given":"Xinhui"}],"citation-key":"liUnleashingWalkingDead2017","container-title":"Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security","DOI":"10.1145/3133956.3134021","event-place":"Dallas Texas USA","event-title":"CCS '17: 2017 ACM SIGSAC Conference on Computer and Communications Security","ISBN":"978-1-4503-4946-8","issued":{"date-parts":[["2017",10,30]]},"language":"en","page":"829-844","publisher":"ACM","publisher-place":"Dallas Texas USA","source":"DOI.org (Crossref)","title":"Unleashing the Walking Dead: Understanding Cross-App Remote Infections on Mobile WebViews","title-short":"Unleashing the Walking Dead","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3133956.3134021"},
  {"id":"liuProMalPreciseWindow2022","abstract":"Mobile apps have been an integral part in our daily life. As these apps become more complex, it is critical to provide automated analysis techniques to ensure the correctness, security, and performance of these apps. A key component for these automated analysis techniques is to create a graphical user interface (GUI) model of an app, i.e., a window transition graph (WTG), that models windows and transitions among the windows. While existing work has provided both static and dynamic analysis to build the WTG for an app, the constructed WTG misses many transitions or contains many infeasible transitions due to the coverage issues of dynamic analysis and over-approximation of the static analysis. We propose ProMal, a “tribrid” analysis that synergistically combines static analysis, dynamic analysis, and machine learning to construct a precise WTG. Specifically, ProMal first applies static analysis to build a static WTG, and then applies dynamic analysis to verify the transitions in the static WTG. For the unverified transitions, ProMal further provides machine learning techniques that leverage runtime information (i.e., screenshots, UI layouts, and text information) to predict whether they are feasible transitions. Our evaluations on 40 real-world apps demonstrate the superiority of ProMal in building WTGs over static analysis, dynamic analysis, and machine learning techniques when they are applied separately.","accessed":{"date-parts":[["2023",5,12]]},"author":[{"family":"Liu","given":"Changlin"},{"family":"Wang","given":"Hanlin"},{"family":"Liu","given":"Tianming"},{"family":"Gu","given":"Diandian"},{"family":"Ma","given":"Yun"},{"family":"Wang","given":"Haoyu"},{"family":"Xiao","given":"Xusheng"}],"citation-key":"liuProMalPreciseWindow2022","container-title":"Proceedings of the 44th International Conference on Software Engineering","DOI":"10.1145/3510003.3510037","event-place":"Pittsburgh Pennsylvania","event-title":"ICSE '22: 44th International Conference on Software Engineering","ISBN":"978-1-4503-9221-1","issued":{"date-parts":[["2022",5,21]]},"language":"en","page":"1755-1767","publisher":"ACM","publisher-place":"Pittsburgh Pennsylvania","source":"DOI.org (Crossref)","title":"ProMal: precise window transition graphs for android via synergy of program analysis and machine learning","title-short":"ProMal","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3510003.3510037"},
  {"id":"luDemystifyingResourceManagement2020","abstract":"App-in-app is a new and trending mobile computing paradigm in which native app-like software modules, called sub-apps, are hosted by popular mobile apps such as Wechat, Alipay, Baidu, TikTok and Chrome, to enrich the host app’s functionalities and to form an “all-in-one app\" ecosystem. Sub-apps access system resources through the host, and their functionalities come close to regular mobile apps (taking photos, recording voices, banking, shopping, etc.). Less clear, however, is whether the host app, typically a thirdparty app, is capable of securely managing sub-apps and their access to system resources. In this paper, we report the first systematic study on the resource management in app-in-app systems. Our study reveals high-impact security flaws, which allow the adversary to stealthily escalate privilege (e.g., accessing the camera, photo gallery, microphone, etc.) or acquire sensitive data (e.g., location, passwords of Amazon, Google, etc.). To understand the impacts of those flaws, we developed an analysis tool that automatically assesses 11 popular app-in-app platforms on both Android and iOS. Our results brought to light the prevalence of the security flaws. We further discuss the lessons learned and propose mitigation strategies.","accessed":{"date-parts":[["2022",12,27]]},"author":[{"family":"Lu","given":"Haoran"},{"family":"Xing","given":"Luyi"},{"family":"Xiao","given":"Yue"},{"family":"Zhang","given":"Yifan"},{"family":"Liao","given":"Xiaojing"},{"family":"Wang","given":"XiaoFeng"},{"family":"Wang","given":"Xueqiang"}],"citation-key":"luDemystifyingResourceManagement2020","container-title":"Proceedings of the 2020 ACM SIGSAC Conference on Computer and Communications Security","DOI":"10.1145/3372297.3417255","event-place":"Virtual Event USA","event-title":"CCS '20: 2020 ACM SIGSAC Conference on Computer and Communications Security","ISBN":"978-1-4503-7089-9","issued":{"date-parts":[["2020",10,30]]},"language":"en","page":"569-585","publisher":"ACM","publisher-place":"Virtual Event USA","source":"DOI.org (Crossref)","title":"Demystifying Resource Management Risks in Emerging Mobile App-in-App Ecosystems","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3372297.3417255"},
  {"id":"lvFastbot2ReusableAutomated2022","abstract":"We introduce a reusable automated model-based GUI testing technique for Android apps to accelerate the testing cycle. Our key insight is that the knowledge of event-activity transitions from the previous testing runs, i.e., executing which events can reach which activities, is valuable for guiding the follow-up testing runs to quickly cover major app functionalities. To this end, we propose (1) a probabilistic model to memorize and leverage this knowledge during testing, and (2) design a model-based guided testing strategy (enhanced by a reinforcement learning algorithm). We implemented our technique as an automated testing tool named Fastbot2. The evaluation on two popular industrial apps (with billions of user installations), Douyin and Toutiao, shows that Fastbot2 outperforms the stateof-the-art testing tools (Monkey, Ape and Stoat) in both activity coverage and fault detection in the context of continuous testing. To date, Fastbot2 has been deployed in the CI pipeline at ByteDance for nearly two years, and 50.8% of the developer-fixed crash bugs were reported by Fastbot2, which significantly improves app quality. Fastbot2 has been made publicly available to benefit the community at: https:// github.com/ bytedance/ Fastbot_Android.","accessed":{"date-parts":[["2023",11,22]]},"author":[{"family":"Lv","given":"Zhengwei"},{"family":"Peng","given":"Chao"},{"family":"Zhang","given":"Zhao"},{"family":"Su","given":"Ting"},{"family":"Liu","given":"Kai"},{"family":"Yang","given":"Ping"}],"citation-key":"lvFastbot2ReusableAutomated2022","container-title":"Proceedings of the 37th IEEE/ACM International Conference on Automated Software Engineering","DOI":"10.1145/3551349.3559505","event-place":"Rochester MI USA","event-title":"ASE '22: 37th IEEE/ACM International Conference on Automated Software Engineering","ISBN":"978-1-4503-9475-8","issued":{"date-parts":[["2022",10,10]]},"language":"en","page":"1-5","publisher":"ACM","publisher-place":"Rochester MI USA","source":"DOI.org (Crossref)","title":"Fastbot2: Reusable Automated Model-based GUI Testing for Android Enhanced by Reinforcement Learning","title-short":"Fastbot2","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3551349.3559505"},
  {"id":"machiryDynodroidInputGeneration2013","abstract":"We present a system Dynodroid for generating relevant inputs to unmodiﬁed Android apps. Dynodroid views an app as an event-driven program that interacts with its environment by means of a sequence of events through the Android framework. By instrumenting the framework once and for all, Dynodroid monitors the reaction of an app upon each event in a lightweight manner, using it to guide the generation of the next event to the app. Dynodroid also allows interleaving events from machines, which are better at generating a large number of simple inputs, with events from humans, who are better at providing intelligent inputs.","accessed":{"date-parts":[["2023",5,31]]},"author":[{"family":"Machiry","given":"Aravind"},{"family":"Tahiliani","given":"Rohan"},{"family":"Naik","given":"Mayur"}],"citation-key":"machiryDynodroidInputGeneration2013","container-title":"Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering","DOI":"10.1145/2491411.2491450","event-place":"Saint Petersburg Russia","event-title":"ESEC/FSE'13: Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering","ISBN":"978-1-4503-2237-9","issued":{"date-parts":[["2013",8,18]]},"language":"en","page":"224-234","publisher":"ACM","publisher-place":"Saint Petersburg Russia","source":"DOI.org (Crossref)","title":"Dynodroid: an input generation system for Android apps","title-short":"Dynodroid","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/2491411.2491450"},
  {"id":"maFine1234Analysis2021","abstract":"A fundamental premise of SMS One-Time Password (OTP) is that the used pseudo-random numbers (PRNs) are uniquely unpredictable for each login session. Hence, the process of generating PRNs is the most critical step in the OTP authentication. An improper implementation of the pseudorandom number generator (PRNG) will result in predictable or even static OTP values, making them vulnerable to potential attacks. In this paper, we present a vulnerability study against PRNGs implemented for Android apps. A key challenge is that PRNGs are typically implemented on the server-side, and thus the source code is not accessible. To resolve this issue, we build an analysis tool, OTP-Lint, to assess implementations of the PRNGs in an automated manner without the source code requirement. Through reverse engineering, OTP-Lint identiﬁes the apps using SMS OTP and triggers each app’s login functionality to retrieve OTP values. It further assesses the randomness of the OTP values to identify vulnerable PRNGs. By analyzing 6,431 commercially used Android apps downloaded from Google Play and Tencent Myapp, OTP-Lint identiﬁed 399 vulnerable apps that generate predictable OTP values. Even worse, 194 vulnerable apps use the OTP authentication alone without any additional security mechanisms, leading to insecure authentication against guessing attacks and replay attacks.","accessed":{"date-parts":[["2022",12,27]]},"author":[{"family":"Ma","given":"Siqi"},{"family":"Li","given":"Juanru"},{"family":"Kim","given":"Hyoungshick"},{"family":"Bertino","given":"Elisa"},{"family":"Nepal","given":"Surya"},{"family":"Ostry","given":"Diethelm"},{"family":"Sun","given":"Cong"}],"citation-key":"maFine1234Analysis2021","issued":{"date-parts":[["2021",3,6]]},"language":"en","number":"arXiv:2103.05758","publisher":"arXiv","source":"arXiv.org","title":"Fine with \"1234\"? An Analysis of SMS One-Time Password Randomness in Android Apps","title-short":"Fine with \"1234\"?","type":"article","URL":"http://arxiv.org/abs/2103.05758"},
  {"id":"mahmoodEvoDroidSegmentedEvolutionary2014","abstract":"Proliferation of Android devices and apps has created a demand for applicable automated software testing techniques. Prior research has primarily focused on either unit or GUI testing of Android apps, but not their end-to-end system testing in a systematic manner. We present EvoDroid, an evolutionary approach for system testing of Android apps. EvoDroid overcomes a key shortcoming of using evolutionary techniques for system testing, i.e., the inability to pass on genetic makeup of good individuals in the search. To that end, EvoDroid combines two novel techniques: (1) an Android-specific program analysis technique that identifies the segments of the code amenable to be searched independently, and (2) an evolutionary algorithm that given information of such segments performs a step-wise search for test cases reaching deep into the code. Our experiments have corroborated EvoDroid’s ability to achieve significantly higher code coverage than existing Android testing tools.","accessed":{"date-parts":[["2023",6,1]]},"author":[{"family":"Mahmood","given":"Riyadh"},{"family":"Mirzaei","given":"Nariman"},{"family":"Malek","given":"Sam"}],"citation-key":"mahmoodEvoDroidSegmentedEvolutionary2014","collection-title":"FSE 2014","container-title":"Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering","DOI":"10.1145/2635868.2635896","event-place":"New York, NY, USA","ISBN":"978-1-4503-3056-5","issued":{"literal":"11 月 11, 2014"},"page":"599–609","publisher":"Association for Computing Machinery","publisher-place":"New York, NY, USA","source":"ACM Digital Library","title":"EvoDroid: segmented evolutionary testing of Android apps","title-short":"EvoDroid","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/2635868.2635896"},
  {"id":"maoSapienzMultiobjectiveAutomated2016","abstract":"We introduce Sapienz, an approach to Android testing that uses multi-objective search-based testing to automatically explore and optimise test sequences, minimising length, while simultaneously maximising coverage and fault revelation. Sapienz combines random fuzzing, systematic and search-based exploration, exploiting seeding and multi-level instrumentation. Sapienz significantly outperforms (with large effect size) both the state-of-the-art technique Dynodroid and the widely-used tool, Android Monkey, in 7/10 experiments for coverage, 7/10 for fault detection and 10/10 for fault-revealing sequence length. When applied to the top 1,000 Google Play apps, Sapienz found 558 unique, previously unknown crashes. So far we have managed to make contact with the developers of 27 crashing apps. Of these, 14 have confirmed that the crashes are caused by real faults. Of those 14, six already have developer-confirmed fixes.","accessed":{"date-parts":[["2023",6,2]]},"author":[{"family":"Mao","given":"Ke"},{"family":"Harman","given":"Mark"},{"family":"Jia","given":"Yue"}],"citation-key":"maoSapienzMultiobjectiveAutomated2016","collection-title":"ISSTA 2016","container-title":"Proceedings of the 25th International Symposium on Software Testing and Analysis","DOI":"10.1145/2931037.2931054","event-place":"New York, NY, USA","ISBN":"978-1-4503-4390-9","issued":{"literal":"7 月 18, 2016"},"page":"94–105","publisher":"Association for Computing Machinery","publisher-place":"New York, NY, USA","source":"ACM Digital Library","title":"Sapienz: multi-objective automated testing for Android applications","title-short":"Sapienz","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/2931037.2931054"},
  {"id":"marianiSemanticMatchingGUI2021","accessed":{"date-parts":[["2023",6,4]]},"author":[{"family":"Mariani","given":"Leonardo"},{"family":"Mohebbi","given":"Ali"},{"family":"Pezzè","given":"Mauro"},{"family":"Terragni","given":"Valerio"}],"citation-key":"marianiSemanticMatchingGUI2021","container-title":"Proceedings of the 30th ACM SIGSOFT International Symposium on Software Testing and Analysis","DOI":"10.1145/3460319.3464827","event-place":"Virtual Denmark","event-title":"ISSTA '21: 30th ACM SIGSOFT International Symposium on Software Testing and Analysis","ISBN":"978-1-4503-8459-9","issued":{"date-parts":[["2021",7,11]]},"language":"en","page":"177-190","publisher":"ACM","publisher-place":"Virtual Denmark","source":"DOI.org (Crossref)","title":"Semantic matching of GUI events for test reuse: are we there yet?","title-short":"Semantic matching of GUI events for test reuse","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3460319.3464827"},
  {"id":"memonGUIRippingReverse2003","author":[{"family":"Memon","given":"A."},{"family":"Banerjee","given":"I."},{"family":"Nagarajan","given":"A."}],"citation-key":"memonGUIRippingReverse2003","container-title":"10th Working Conference on Reverse Engineering, 2003. WCRE 2003. Proceedings.","DOI":"10.1109/WCRE.2003.1287256","event-title":"10th Working Conference on Reverse Engineering, 2003. WCRE 2003. Proceedings.","ISSN":"1095-1350","issued":{"date-parts":[["2003",1]]},"page":"260-269","source":"IEEE Xplore","title":"GUI ripping: reverse engineering of graphical user interfaces for testing","title-short":"GUI ripping","type":"paper-conference"},
  {"id":"mirzaeiReducingCombinatoricsGUI2016","abstract":"The rising popularity of Android and the GUI-driven nature of its apps have motivated the need for applicable automated GUI testing techniques. Although exhaustive testing of all possible combinations is the ideal upper bound in combinatorial testing, it is often infeasible, due to the combinatorial explosion of test cases. This paper presents TrimDroid, a framework for GUI testing of Android apps that uses a novel strategy to generate tests in a combinatorial, yet scalable, fashion. It is backed with automated program analysis and formally rigorous test generation engines. TrimDroid relies on program analysis to extract formal specifications. These specifications express the app's behavior (i.e., control flow between the various app screens) as well as the GUI elements and their dependencies. The dependencies among the GUI elements comprising the app are used to reduce the number of combinations with the help of a solver. Our experiments have corroborated TrimDroid's ability to achieve a comparable coverage as that possible under exhaustive GUI testing using significantly fewer test cases.","accessed":{"date-parts":[["2023",6,2]]},"author":[{"family":"Mirzaei","given":"Nariman"},{"family":"Garcia","given":"Joshua"},{"family":"Bagheri","given":"Hamid"},{"family":"Sadeghi","given":"Alireza"},{"family":"Malek","given":"Sam"}],"citation-key":"mirzaeiReducingCombinatoricsGUI2016","collection-title":"ICSE '16","container-title":"Proceedings of the 38th International Conference on Software Engineering","DOI":"10.1145/2884781.2884853","event-place":"New York, NY, USA","ISBN":"978-1-4503-3900-1","issued":{"literal":"5 月 14, 2016"},"page":"559–570","publisher":"Association for Computing Machinery","publisher-place":"New York, NY, USA","source":"ACM Digital Library","title":"Reducing combinatorics in GUI testing of android applications","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/2884781.2884853"},
  {"id":"ohDeViewConfiningProgressive2022","abstract":"A progressive web application (PWA) becomes an attractive option for building universal applications based on feature-rich web Application Programming Interfaces (APIs). While flexible, such vast APIs inevitably bring a significant increase in an API attack surface, which commonly corresponds to a functionality that is neither needed nor wanted by the application. A promising approach to reduce the API attack surface is software debloating, a technique wherein an unused functionality is programmatically removed from an application. Unfortunately, debloating PWAs is challenging, given the monolithic design and non-deterministic execution of a modern web browser. In this paper, we present DeView, a practical approach that reduces the attack surface of a PWA by blocking unnecessary but accessible web APIs. DeView tackles the challenges of PWA debloating by i) record-and-replay web API profiling that identifies needed web APIs on an app-by-app basis by replaying (recorded) browser interactions and ii) compiler-assisted browser debloating that eliminates the entry functions of corresponding web APIs from the mapping between web API and its entry point in a binary. Our evaluation shows the effectiveness and practicality of DeView. DeView successfully eliminates 91.8% of accessible web APIs while i) maintaining original functionalities and ii) preventing 76.3% of known exploits on average.","accessed":{"date-parts":[["2023",4,13]]},"author":[{"family":"Oh","given":"ChangSeok"},{"family":"Lee","given":"Sangho"},{"family":"Qian","given":"Chenxiong"},{"family":"Koo","given":"Hyungjoon"},{"family":"Lee","given":"Wenke"}],"citation-key":"ohDeViewConfiningProgressive2022","container-title":"Proceedings of the 38th Annual Computer Security Applications Conference","DOI":"10.1145/3564625.3567987","event-place":"Austin TX USA","event-title":"ACSAC: Annual Computer Security Applications Conference","ISBN":"978-1-4503-9759-9","issued":{"date-parts":[["2022",12,5]]},"language":"en","page":"881-895","publisher":"ACM","publisher-place":"Austin TX USA","source":"DOI.org (Crossref)","title":"DeView: Confining Progressive Web Applications by Debloating Web APIs","title-short":"DeView","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3564625.3567987"},
  {"id":"panReinforcementLearningBased2020","accessed":{"date-parts":[["2023",6,28]]},"author":[{"family":"Pan","given":"Minxue"},{"family":"Huang","given":"An"},{"family":"Wang","given":"Guoxin"},{"family":"Zhang","given":"Tian"},{"family":"Li","given":"Xuandong"}],"citation-key":"panReinforcementLearningBased2020","container-title":"Proceedings of the 29th ACM SIGSOFT International Symposium on Software Testing and Analysis","DOI":"10.1145/3395363.3397354","event-place":"Virtual Event USA","event-title":"ISSTA '20: 29th ACM SIGSOFT International Symposium on Software Testing and Analysis","ISBN":"978-1-4503-8008-9","issued":{"date-parts":[["2020",7,18]]},"language":"en","page":"153-164","publisher":"ACM","publisher-place":"Virtual Event USA","source":"DOI.org (Crossref)","title":"Reinforcement learning based curiosity-driven testing of Android applications","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3395363.3397354"},
  {"id":"philippaertsOAuchExploringSecurity2022a","abstract":"The OAuth 2.0 protocol is a popular and widely adopted authorization protocol. It has been proven secure in a comprehensive formal security analysis, yet new vulnerabilities continue to appear in popular OAuth implementations.","author":[{"family":"Philippaerts","given":"Pieter"},{"family":"Preuveneers","given":"Davy"},{"family":"Joosen","given":"Wouter"}],"citation-key":"philippaertsOAuchExploringSecurity2022a","issued":{"date-parts":[["2022"]]},"language":"en","source":"Zotero","title":"OAuch: Exploring Security Compliance in the OAuth 2.0 Ecosystem","type":"article-journal"},
  {"id":"possematoPreventingDetectingState2021","abstract":"In the realm of the Android ecosystem, one relevant threat is posed by phishing attacks. Phishing attacks are particularly problematic for mobile platforms because they do not provide enough information for a user to reliably distinguish a legitimate app from a malicious app spoofing the UI of the legitimate one. A key factor that determines the success rate of a phishing attack is proper timing: The user is more prone to provide sensitive data (such as her passwords) if the malicious spoofed UI appears when the victim expects to interact with the target app. On Android, malware determines the right timing by mounting so-called state inference attacks, which can be used, for example, to infer the exact moment that the user started a target app and thus expects to interact with it. Even though Android app sandbox is designed to prevent these attacks, they are still possible by abusing vulnerable APIs that leak such sensitive information: the usual scenario is a malicious app that “polls” these vulnerable APIs, infers when a target app is about to be used by the user, and makes the spoofed UI appear on top of the screen at the right time. All previous bugs of this kind have been fixed in the latest version of Android.","accessed":{"date-parts":[["2022",12,27]]},"author":[{"family":"Possemato","given":"Andrea"},{"family":"Nisi","given":"Dario"},{"family":"Fratantonio","given":"Yanick"}],"citation-key":"possematoPreventingDetectingState2021","container-title":"Proceedings 2021 Network and Distributed System Security Symposium","DOI":"10.14722/ndss.2021.24479","event-place":"Virtual","event-title":"Network and Distributed System Security Symposium","ISBN":"978-1-891562-66-2","issued":{"date-parts":[["2021"]]},"language":"en","publisher":"Internet Society","publisher-place":"Virtual","source":"DOI.org (Crossref)","title":"Preventing and Detecting State Inference Attacks on Android","type":"paper-conference","URL":"https://www.ndss-symposium.org/wp-content/uploads/ndss2021_3B-5_24479_paper.pdf"},
  {"id":"reardon50WaysLeak","abstract":"Modern smartphone platforms implement permission-based models to protect access to sensitive data and system resources. However, apps can circumvent the permission model and gain access to protected data without user consent by using both covert and side channels. Side channels present in the implementation of the permission system allow apps to access protected data and system resources without permission; whereas covert channels enable communication between two colluding apps so that one app can share its permissionprotected data with another app lacking those permissions. Both pose threats to user privacy.","author":[{"family":"Reardon","given":"Joel"},{"family":"Feal","given":"Álvaro"},{"family":"Wijesekera","given":"Primal"}],"citation-key":"reardon50WaysLeak","language":"en","source":"Zotero","title":"50 Ways to Leak Your Data: An Exploration of Apps’ Circumvention of the Android Permissions System","type":"article-journal"},
  {"id":"santhanamScrapingStickyLeftovers2022","abstract":"Sixty-ﬁve percent of mobile apps require user accounts for offering fullﬂedged functionality. Account information includes private data, e.g., address, phone number, credit card. Our concern is “leftover” account data kept on the server after account deletion, which can be a signiﬁcant privacy violation. Speciﬁcally, we analyzed 1,435 popular apps from Google Play (and 771 associated websites), of which 678 have their own sign-up process, to answer questions such as: Can accounts be deleted at all? Following account deletion, will user data remain on the app’s servers? If so, for how long? Do apps keep their promise to remove data? Answering these questions, and more generally, understanding and tackling the leftover account problem, is challenging. A fundamental obstacle is that leftover data is manipulated and retained in a private space, on the app’s backend servers; we devised a novel, reverse-engineering approach to infer leftover data from app–server communication. Another obstacle is the distributed nature of this data: program analysis as well as information retrieval are required on both the app and its website. We have developed an end-to-end solution (static analysis, dynamic analysis, natural language processing) to the leftover account problem. First, our toolchain checks whether an app, or its website, support account deletion; next, it checks whether the app/website have a data retention policy, and whether the account is left on servers after deletion, or after the speciﬁed retention period; ﬁnally, it automatically cleans up leftover accounts. We found that 64.45% of apps do not offer any means for users to delete accounts; 2.5% of apps still keep account data on app servers even after accounts are deleted by users. Only 5% of apps specify a retention period; some of these apps violate their own policy by still retaining data months after the period has ended. Experiments show that our approach is effective, with an F-measure > 88%, and efﬁcient, with a typical analysis time of 279 seconds per app/website.","accessed":{"date-parts":[["2022",12,27]]},"author":[{"family":"Santhanam","given":"Preethi"},{"family":"Dang","given":"Hoang"},{"family":"Shan","given":"Zhiyong"},{"family":"Neamtiu","given":"Iulian"}],"citation-key":"santhanamScrapingStickyLeftovers2022","container-title":"2022 IEEE Symposium on Security and Privacy (SP)","DOI":"10.1109/SP46214.2022.9833720","event-place":"San Francisco, CA, USA","event-title":"2022 IEEE Symposium on Security and Privacy (SP)","ISBN":"978-1-66541-316-9","issued":{"date-parts":[["2022",5]]},"language":"en","page":"2145-2160","publisher":"IEEE","publisher-place":"San Francisco, CA, USA","source":"DOI.org (Crossref)","title":"Scraping Sticky Leftovers: App User Information Left on Servers After Account Deletion","title-short":"Scraping Sticky Leftovers","type":"paper-conference","URL":"https://ieeexplore.ieee.org/document/9833720/"},
  {"id":"seguraMetamorphicTestingRESTful2018","abstract":"Web Application Programming Interfaces (APIs) allow systems to interact with each other over the network. Modern Web APIs often adhere to the REST architectural style, being referred to as RESTful Web APIs. RESTful Web APIs are decomposed into multiple resources (e.g., a video in the YouTube API) that clients can manipulate through HTTP interactions. Testing Web APIs is critical but challenging due to the difﬁculty to assess the correctness of API responses, i.e., the oracle problem. Metamorphic testing alleviates the oracle problem by exploiting relations (so-called metamorphic relations) among multiple executions of the program under test. In this paper, we present a metamorphic testing approach for the detection of faults in RESTful Web APIs. We ﬁrst propose six abstract relations that capture the shape of many of the metamorphic relations found in RESTful Web APIs, we call these Metamorphic Relation Output Patterns (MROPs). Each MROP can then be instantiated into one or more concrete metamorphic relations. The approach was evaluated using both automatically seeded and real faults in six subject Web APIs. Among other results, we identiﬁed 60 metamorphic relations (instances of the proposed MROPs) in the Web APIs of Spotify and YouTube. Each metamorphic relation was implemented using both random and manual test data, running over 4.7K automated tests. As a result, 11 issues were detected (3 in Spotify and 8 in YouTube), 10 of them conﬁrmed by the API developers or reproduced by other users, supporting the effectiveness of the approach.","accessed":{"date-parts":[["2022",12,28]]},"author":[{"family":"Segura","given":"Sergio"},{"family":"Parejo","given":"Jose A."},{"family":"Troya","given":"Javier"},{"family":"Ruiz-Cortes","given":"Antonio"}],"citation-key":"seguraMetamorphicTestingRESTful2018","container-title":"IEEE Transactions on Software Engineering","container-title-short":"IIEEE Trans. Software Eng.","DOI":"10.1109/TSE.2017.2764464","ISSN":"0098-5589, 1939-3520, 2326-3881","issue":"11","issued":{"date-parts":[["2018",11,1]]},"language":"en","page":"1083-1099","source":"DOI.org (Crossref)","title":"Metamorphic Testing of RESTful Web APIs","type":"article-journal","URL":"https://ieeexplore.ieee.org/document/8074764/","volume":"44"},
  {"id":"shezanTKPERMCrossplatformPermission2020","abstract":"Permission-based access control enables users to manage and control their sensitive data for third-party applications. In an ideal scenario, third-party application includes enough details to illustrate the usage of such data, while the reality is that many descriptions of third-party applications are vague about their security or privacy activities. As a result, users are left with insufﬁcient details when granting sensitive data to these applications. Prior works, such as WHYPER and AutoCog, have addressed the aforementioned problem via a so-called permission correlation system. Such a system correlates thirdparty applications’ description with their requested permissions and determines an application as overprivileged, if a mismatch between the requested permission and the description is found. However, although prior works are successful on their own platforms, such as Android eco-system, they are not directly applicable to new platforms, such as Chrome extensions and IFTTT, without extensive data labeling and parameter tuning.","accessed":{"date-parts":[["2022",12,27]]},"author":[{"family":"Shezan","given":"Faysal Hossain"},{"family":"Cheng","given":"Kaiming"},{"family":"Zhang","given":"Zhen"},{"family":"Cao","given":"Yinzhi"},{"family":"Tian","given":"Yuan"}],"citation-key":"shezanTKPERMCrossplatformPermission2020","container-title":"Proceedings 2020 Network and Distributed System Security Symposium","DOI":"10.14722/ndss.2020.24287","event-place":"San Diego, CA","event-title":"Network and Distributed System Security Symposium","ISBN":"978-1-891562-61-7","issued":{"date-parts":[["2020"]]},"language":"en","publisher":"Internet Society","publisher-place":"San Diego, CA","source":"DOI.org (Crossref)","title":"TKPERM: Cross-platform Permission Knowledge Transfer to Detect Overprivileged Third-party Applications","title-short":"TKPERM","type":"paper-conference","URL":"https://www.ndss-symposium.org/wp-content/uploads/2020/02/24287.pdf"},
  {"id":"songUnderstandingJavaScriptVulnerabilities2020","abstract":"JavaScript-related vulnerabilities are becoming a major security threat to hybrid mobile applications. In this article, we present a systematic study to understand how JavaScript is used in real-world Android apps and how it may lead to security vulnerabilities. We begin by conducting an empirical study on the top-100 most popular Android apps to investigate JavaScript usage and its related security vulnerabilities. Our study identiﬁes four categories of JavaScript usage and ﬁnds that three of these categories, if inappropriately used, can respectively lead to three types of vulnerabilities. We also design and implement an automatic tool named JSDroid to detect JavaScript-related vulnerabilities. We have applied JSDroid to 1,000 large real-world Android apps and found that over 70% of these apps have potential JavaScript-related vulnerabilities and 20% of them can be successfully exploited. Moreover, based on the vulnerabilities identiﬁed by JSDroid, we have successfully launched real attacks on 30 real-world apps.","accessed":{"date-parts":[["2022",12,27]]},"author":[{"family":"Song","given":"Wei"},{"family":"Huang","given":"Qingqing"},{"family":"Huang","given":"Jeff"}],"citation-key":"songUnderstandingJavaScriptVulnerabilities2020","container-title":"IEEE Transactions on Dependable and Secure Computing","container-title-short":"IEEE Trans. Dependable and Secure Comput.","DOI":"10.1109/TDSC.2018.2845851","ISSN":"1545-5971, 1941-0018, 2160-9209","issue":"5","issued":{"date-parts":[["2020",9,1]]},"language":"en","page":"1063-1078","source":"DOI.org (Crossref)","title":"Understanding JavaScript Vulnerabilities in Large Real-World Android Applications","type":"article-journal","URL":"https://ieeexplore.ieee.org/document/8378244/","volume":"17"},
  {"id":"suBenchmarkingAutomatedGUI2021","abstract":"For ensuring the reliability of Android apps, there has been tremendous, continuous progress on improving automated GUI testing in the past decade. Specifically, dozens of testing techniques and tools have been developed and demonstrated to be effective in detecting crash bugs and outperform their respective prior work in the number of detected crashes. However, an overarching question łHow effectively and thoroughly can these tools find crash bugs in practice?ž has not been well-explored, which requires a ground-truth benchmark with real-world bugs. Since prior studies focus on tool comparisons w.r.t. some selected apps, they cannot provide direct, in-depth answers to this question.","accessed":{"date-parts":[["2023",6,4]]},"author":[{"family":"Su","given":"Ting"},{"family":"Wang","given":"Jue"},{"family":"Su","given":"Zhendong"}],"citation-key":"suBenchmarkingAutomatedGUI2021","container-title":"Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering","DOI":"10.1145/3468264.3468620","event-place":"Athens Greece","event-title":"ESEC/FSE '21: 29th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering","ISBN":"978-1-4503-8562-6","issued":{"date-parts":[["2021",8,20]]},"language":"en","page":"119-130","publisher":"ACM","publisher-place":"Athens Greece","source":"DOI.org (Crossref)","title":"Benchmarking automated GUI testing for Android against real-world bugs","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3468264.3468620"},
  {"id":"suFSMdroidGuidedGUI2016","accessed":{"date-parts":[["2023",6,2]]},"author":[{"family":"Su","given":"Ting"}],"citation-key":"suFSMdroidGuidedGUI2016","container-title":"Proceedings of the 38th International Conference on Software Engineering Companion","DOI":"10.1145/2889160.2891043","event-place":"Austin Texas","event-title":"ICSE '16: 38th International Conference on Software Engineering","ISBN":"978-1-4503-4205-6","issued":{"date-parts":[["2016",5,14]]},"language":"en","page":"689-691","publisher":"ACM","publisher-place":"Austin Texas","source":"DOI.org (Crossref)","title":"FSMdroid: guided GUI testing of android apps","title-short":"FSMdroid","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/2889160.2891043"},
  {"id":"suFullyAutomatedFunctional2021","abstract":"Android apps are GUI-based event-driven software and have become ubiquitous in recent years. Obviously, functional correctness is critical for an app’s success. However, in addition to crash bugs,\n              non-crashing functional bugs\n              (in short as “non-crashing bugs” in this work) like inadvertent function failures, silent user data lost and incorrect display information are prevalent, even in popular, well-tested apps. These non-crashing functional bugs are usually caused by program logic errors and manifest themselves on the graphic user interfaces (GUIs). In practice, such bugs pose significant challenges in effectively detecting them because (1) current practices heavily rely on expensive, small-scale manual validation (\n              the lack of automation\n              ); and (2) modern\n              fully automated\n              testing has been limited to crash bugs (\n              the lack of test oracles\n              ).\n            \n            \n              This paper fills this gap by introducing\n              independent view fuzzing\n              ,\n              a novel, fully automated approach\n              for detecting non-crashing functional bugs in Android apps. Inspired by metamorphic testing, our key insight is to leverage the commonly-held\n              independent view property\n              of Android apps to manufacture property-preserving mutant tests from a set of seed tests that validate certain app properties. The mutated tests help exercise the tested apps under additional, adverse conditions. Any property violations indicate likely functional bugs for further manual confirmation. We have realized our approach as an automated, end-to-end functional fuzzing tool, Genie. Given an app, (1) Genie automatically detects non-crashing bugs without requiring human-provided tests and oracles (thus\n              fully automated\n              ); and (2) the detected non-crashing bugs are diverse (thus\n              general and not limited to specific functional properties\n              ), which set Genie apart from prior work.\n            \n            We have evaluated Genie on 12 real-world Android apps and successfully uncovered 34 previously unknown non-crashing bugs in their latest releases — all have been confirmed, and 22 have already been fixed. Most of the detected bugs are nontrivial and have escaped developer (and user) testing for at least one year and affected many app releases, thus clearly demonstrating Genie’s effectiveness. According to our analysis, Genie achieves a reasonable true positive rate of 40.9%, while these 34 non-crashing bugs could not be detected by prior fully automated GUI testing tools (as our evaluation confirms). Thus, our work complements and enhances existing manual testing and fully automated testing for crash bugs.","accessed":{"date-parts":[["2022",12,28]]},"author":[{"family":"Su","given":"Ting"},{"family":"Yan","given":"Yichen"},{"family":"Wang","given":"Jue"},{"family":"Sun","given":"Jingling"},{"family":"Xiong","given":"Yiheng"},{"family":"Pu","given":"Geguang"},{"family":"Wang","given":"Ke"},{"family":"Su","given":"Zhendong"}],"citation-key":"suFullyAutomatedFunctional2021","container-title":"Proceedings of the ACM on Programming Languages","container-title-short":"Proc. ACM Program. Lang.","DOI":"10.1145/3485533","ISSN":"2475-1421","issue":"OOPSLA","issued":{"date-parts":[["2021",10,20]]},"language":"en","page":"1-31","source":"DOI.org (Crossref)","title":"Fully automated functional fuzzing of Android apps for detecting non-crashing logic bugs","type":"article-journal","URL":"https://dl.acm.org/doi/10.1145/3485533","volume":"5"},
  {"id":"suGuidedStochasticModelbased2017","abstract":"Mobile apps are ubiquitous, operate in complex environments and are developed under the time-to-market pressure. Ensuring their correctness and reliability thus becomes an important challenge. This paper introduces Stoat, a novel guided approach to perform stochastic model-based testing on Android apps. Stoat operates in two phases: (1) Given an app as input, it uses dynamic analysis enhanced by a weighted UI exploration strategy and static analysis to reverse engineer a stochastic model of the app’s GUI interactions; and (2) it adapts Gibbs sampling to iteratively mutate/refine the stochastic model and guides test generation from the mutated models toward achieving high code and model coverage and exhibiting diverse sequences. During testing, system-level events are randomly injected to further enhance the testing effectiveness. Stoat was evaluated on 93 open-source apps. The results show (1) the models produced by Stoat cover 17∼31% more code than those by existing modeling tools; (2) Stoat detects 3X more unique crashes than two state-of-the-art testing tools, Monkey and Sapienz. Furthermore, Stoat tested 1661 most popular Google Play apps, and detected 2110 previously unknown and unique crashes. So far, 43 developers have responded that they are investigating our reports. 20 of reported crashes have been confirmed, and 8 already fixed.","accessed":{"date-parts":[["2023",6,2]]},"author":[{"family":"Su","given":"Ting"},{"family":"Meng","given":"Guozhu"},{"family":"Chen","given":"Yuting"},{"family":"Wu","given":"Ke"},{"family":"Yang","given":"Weiming"},{"family":"Yao","given":"Yao"},{"family":"Pu","given":"Geguang"},{"family":"Liu","given":"Yang"},{"family":"Su","given":"Zhendong"}],"citation-key":"suGuidedStochasticModelbased2017","container-title":"Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering","DOI":"10.1145/3106237.3106298","event-place":"Paderborn Germany","event-title":"ESEC/FSE'17: Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering","ISBN":"978-1-4503-5105-8","issued":{"date-parts":[["2017",8,21]]},"language":"en","page":"245-256","publisher":"ACM","publisher-place":"Paderborn Germany","source":"DOI.org (Crossref)","title":"Guided, stochastic model-based GUI testing of Android apps","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3106237.3106298"},
  {"id":"suWhyMyApp2022","abstract":"Mobile apps have become ubiquitous. Ensuring their correctness and reliability is important. However, many apps still suffer from occasional to frequent crashes, weakening their competitive edge. Large-scale, deep analyses of the characteristics of real-world app crashes can provide useful insights to both developers and researchers. However, such studies are difficult and yet to be carried out — this work fills this gap. We collected 16,245 and 8,760 unique exceptions from 2,486 open-source and 3,230 commercial Android apps, respectively, and observed that the exceptions thrown from Android framework (termed “framework-specific exceptions”) account for the majority. With one-year effort, we (1) extensively investigated these framework-specific exceptions, and (2) further conducted an online survey of 135 professional app developers about how they analyze, test, reproduce and fix these exceptions. Specifically, we aim to understand the framework-specific exceptions from several perspectives: (i) their characteristics (e.g., manifestation locations, fault taxonomy), (ii) the developers’ testing practices, (iii) existing bug detection techniques’ effectiveness, (iv) their reproducibility and (v) bug fixes. To enable follow-up research (e.g., bug understanding, detection, localization and repairing), we further systematically constructed, DroidDefects, the first comprehensive and largest benchmark of Android app exception bugs. This benchmark contains 33 reproducible exceptions (with test cases, stack traces, faulty and fixed app versions, bug types, etc.), and 3,696 ground-truth exceptions (real faults manifested by automated testing tools), which cover the apps with different complexities and diverse exception types. Based on our findings, we also built two prototype tools: Stoat+, an optimized dynamic testing tool, which quickly uncovered three previously-unknown, fixed crashes in Gmail and Google+; ExLocator, an exception localization tool, which can locate the root causes of specific exception types. Our dataset, benchmark and tools are publicly available on https://github.com/tingsu/droiddefects.","author":[{"family":"Su","given":"Ting"},{"family":"Fan","given":"Lingling"},{"family":"Chen","given":"Sen"},{"family":"Liu","given":"Yang"},{"family":"Xu","given":"Lihua"},{"family":"Pu","given":"Geguang"},{"family":"Su","given":"Zhendong"}],"citation-key":"suWhyMyApp2022","container-title":"IEEE Transactions on Software Engineering","DOI":"10.1109/TSE.2020.3013438","ISSN":"1939-3520","issue":"4","issued":{"date-parts":[["2022",4]]},"page":"1115-1137","source":"IEEE Xplore","title":"Why My App Crashes? Understanding and Benchmarking Framework-Specific Exceptions of Android Apps","title-short":"Why My App Crashes?","type":"article-journal","volume":"48"},
  {"id":"tuncayDracoSystemUniform2016","abstract":"In-app embedded browsers are commonly used by app developers to display web content without having to redirect the user to heavyweight web browsers. Just like the conventional web browsers, embedded browsers can allow the execution of web code. In addition, they provide mechanisms (viz., JavaScript bridges) to give web code access to internal app code that might implement critical functionalities and expose device resources. This is intrinsically dangerous since there is currently no means for app developers to perform origin-based access control on the JavaScript bridges, and any web code running in an embedded browser is free to use all the exposed app and device resources. Previous work that addresses this problem provided access control solutions that work only for apps that are built using hybrid frameworks. Additionally, these solutions focused on protecting only the parts of JavaScript bridges that expose permissions-protected resources. In this work, our goal is to provide a generic solution that works for all apps that utilize embedded web browsers and protects all channels that give access to internal app and device resources. Towards realizing this goal, we built Draco, a uniform and ﬁne-grained access control framework for web code running on Android embedded browsers (viz., WebView). Draco provides a declarative policy language that allows developers to deﬁne policies to specify the desired access characteristics of web origins in a ﬁne-grained fashion, and a runtime system that dynamically enforces the policies. In contrast with previous work, we do not assume any modiﬁcations to the Android operating system, and implement Draco in the Chromium Android System WebView app to enable seamless deployment. Our evaluation of the the Draco runtime system shows that Draco incurs negligible overhead, which is in the order of microseconds.","accessed":{"date-parts":[["2022",12,27]]},"author":[{"family":"Tuncay","given":"Guliz Seray"},{"family":"Demetriou","given":"Soteris"},{"family":"Gunter","given":"Carl A."}],"citation-key":"tuncayDracoSystemUniform2016","container-title":"Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security","DOI":"10.1145/2976749.2978322","event-place":"Vienna Austria","event-title":"CCS'16: 2016 ACM SIGSAC Conference on Computer and Communications Security","ISBN":"978-1-4503-4139-4","issued":{"date-parts":[["2016",10,24]]},"language":"en","page":"104-115","publisher":"ACM","publisher-place":"Vienna Austria","source":"DOI.org (Crossref)","title":"Draco: A System for Uniform and Fine-grained Access Control for Web Code on Android","title-short":"Draco","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/2976749.2978322"},
  {"id":"wangComboDroidGeneratingHighquality2020","abstract":"Android apps demand high-quality test inputs, whose generation remains an open challenge. Existing techniques fall short on exploring complex app functionalities reachable only by a long, meaningful, and effective test input. Observing that such test inputs can usually be decomposed into relatively independent short use cases, this paper presents ComboDroid, a fundamentally different Android app testing framework. ComboDroid obtains use cases for manifesting a specific app functionality (either manually provided or automatically extracted), and systematically enumerates the combinations of use cases, yielding high-quality test inputs. The evaluation results of ComboDroid on real-world apps are encouraging. Our fully automatic variant outperformed the best existing technique APE by covering 4.6% more code (APE only outperformed Monkey by 2.1%), and revealed four previously unknown bugs in extensively tested subjects. Our semi-automatic variant boosts the manual use cases obtained with little manual labor, achieving a comparable coverage (only 3.2% less) with a white-box human testing expert.","accessed":{"date-parts":[["2023",6,2]]},"author":[{"family":"Wang","given":"Jue"},{"family":"Jiang","given":"Yanyan"},{"family":"Xu","given":"Chang"},{"family":"Cao","given":"Chun"},{"family":"Ma","given":"Xiaoxing"},{"family":"Lu","given":"Jian"}],"citation-key":"wangComboDroidGeneratingHighquality2020","collection-title":"ICSE '20","container-title":"Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering","DOI":"10.1145/3377811.3380382","event-place":"New York, NY, USA","ISBN":"978-1-4503-7121-6","issued":{"literal":"10 月 1, 2020"},"page":"469–480","publisher":"Association for Computing Machinery","publisher-place":"New York, NY, USA","source":"ACM Digital Library","title":"ComboDroid: generating high-quality test inputs for Android apps via use case combinations","title-short":"ComboDroid","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3377811.3380382"},
  {"id":"wangVetIdentifyingAvoiding2021","abstract":"Despite over a decade of research, it is still challenging for mobile UI testing tools to achieve satisfactory effectiveness, especially on industrial apps with rich features and large code bases. Our experiences suggest that existing mobile UI testing tools are prone to exploration tarpits, where the tools get stuck with a small fraction of app functionalities for an extensive amount of time. For example, a tool logs out an app at early stages without being able to log back in, and since then the tool gets stuck with exploring the app’s pre-login functionalities (i.e., exploration tarpits) instead of its main functionalities. While tool vendors/users can manually hardcode rules for the tools to avoid specific exploration tarpits, these rules can hardly generalize, being fragile in face of diverted testing environments, fast app iterations, and the demand of batch testing product lines. To identify and resolve exploration tarpits, we propose Vet, a general approach including a supporting system for the given specific Android UI testing tool on the given specific app under test (AUT). Vet runs the tool on the AUT for some time and records UI traces, based on which Vet identifies exploration tarpits by recognizing their patterns in the UI traces. Vet then pinpoints the actions (e.g., clicking logout) or the screens that lead to or exhibit exploration tarpits. In subsequent test runs, Vet guides the testing tool to prevent or recover from exploration tarpits. From our evaluation with state-of-the-art Android UI testing tools on popular industrial apps, Vet identifies exploration tarpits that cost up to 98.6% testing time budget. These exploration tarpits reveal not only limitations in UI exploration strategies but also defects in tool implementations. Vet automatically addresses the identified exploration tarpits, enabling each evaluated tool to achieve higher code coverage and improve crash-triggering capabilities.","accessed":{"date-parts":[["2023",6,5]]},"author":[{"family":"Wang","given":"Wenyu"},{"family":"Yang","given":"Wei"},{"family":"Xu","given":"Tianyin"},{"family":"Xie","given":"Tao"}],"citation-key":"wangVetIdentifyingAvoiding2021","container-title":"Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering","DOI":"10.1145/3468264.3468554","event-place":"Athens Greece","event-title":"ESEC/FSE '21: 29th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering","ISBN":"978-1-4503-8562-6","issued":{"date-parts":[["2021",8,20]]},"language":"en","page":"83-94","publisher":"ACM","publisher-place":"Athens Greece","source":"DOI.org (Crossref)","title":"Vet: identifying and avoiding UI exploration tarpits","title-short":"Vet","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3468264.3468554"},
  {"id":"xiaoIconIntentAutomaticIdentification2019","abstract":"Many mobile applications (i.e., apps) include UI widgets to use or collect users’ sensitive data. Thus, to identify suspicious sensitive data usage such as UI-permission mismatch, it is crucial to understand the intentions of UI widgets. However, many UI widgets leverage icons of speciﬁc shapes (object icons) and icons embedded with text (text icons) to express their intentions, posing challenges for existing detection techniques that analyze only textual data to identify sensitive UI widgets. In this work, we propose a novel app analysis framework, ICONINTENT, that synergistically combines program analysis and icon classiﬁcation to identify sensitive UI widgets in Android apps. ICONINTENT automatically associates UI widgets and icons via static analysis on app’s UI layout ﬁles and code, and then adapts computer vision techniques to classify the associated icons into eight categories of sensitive data. Our evaluations of ICONINTENT on 150 apps from Google Play show that ICONINTENT can detect 248 sensitive UI widgets in 97 apps, achieving a precision of 82.4%. When combined with SUPOR, the state-of-the-art sensitive UI widget identiﬁcation technique based on text analysis, SUPOR +ICONINTENT can detect 487 sensitive UI widgets (101.2% improvement over SUPOR only), and reduces suspicious permissions to be inspected by 50.7% (129.4% improvement over SUPOR only).","accessed":{"date-parts":[["2023",5,12]]},"author":[{"family":"Xiao","given":"Xusheng"},{"family":"Wang","given":"Xiaoyin"},{"family":"Cao","given":"Zhihao"},{"family":"Wang","given":"Hanlin"},{"family":"Gao","given":"Peng"}],"citation-key":"xiaoIconIntentAutomaticIdentification2019","container-title":"2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)","DOI":"10.1109/ICSE.2019.00041","event-place":"Montreal, QC, Canada","event-title":"2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)","ISBN":"978-1-72810-869-8","issued":{"date-parts":[["2019",5]]},"language":"en","page":"257-268","publisher":"IEEE","publisher-place":"Montreal, QC, Canada","source":"DOI.org (Crossref)","title":"IconIntent: Automatic Identification of Sensitive UI Widgets Based on Icon Classification for Android Apps","title-short":"IconIntent","type":"paper-conference","URL":"https://ieeexplore.ieee.org/document/8812108/"},
  {"id":"xiaoUnderstandingMitigatingRemote2022","abstract":"JavaScript cross-platform frameworks are becoming increasingly popular. They help developers easily and conveniently build crossplatform applications while just needing only one JavaScript codebase. Recent security reports showed several high-profile crossplatform applications (e.g., Slack, Microsoft Teams, and Github Atom) suffered injection issues, which were often introduced by Cross-site Scripting (XSS) or embedded untrusted remote content like ads. These injections open security holes for remote web attackers, and cause serious security risks, such as allowing injected malicious code to run arbitrary local executables in victim devices (referred to as “Xrce” attacks). However, until now, Xrce vectors and behaviors and the root cause of Xrce were rarely studied and understood. Although the cross-platform framework developers and community responded quickly by offering multiple security features and suggestions, these mitigations were empirically proposed with unknown effectiveness. In this paper, we conduct the first systematic study of the Xrce vulnerability class in the cross-platform ecosystem. We first build a generic model for different cross-platform applications to reduce their semantic and behavioral gaps. We use this model to (1) study Xrce by comprehensively defining its attack scenarios, surfaces, and behaviors, (2) investigate and study the state-of-theart defenses, and verify their weakness against Xrce attacks. Our study on 640 real-world cross-platform applications shows, despite the availability of existing defenses, Xrce widely affects the crossplatform ecosystem. 75% of applications may be impacted by Xrce, including Microsoft Teams. (3) Finally, we propose XGuard, a novel defense technology to automatically mitigate all Xrce variants derived from our concluded Xrce behaviors.","accessed":{"date-parts":[["2023",2,21]]},"author":[{"family":"Xiao","given":"Feng"},{"family":"Yang","given":"Zheng"},{"family":"Allen","given":"Joey"},{"family":"Yang","given":"Guangliang"},{"family":"Williams","given":"Grant"},{"family":"Lee","given":"Wenke"}],"citation-key":"xiaoUnderstandingMitigatingRemote2022","container-title":"Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security","DOI":"10.1145/3548606.3559340","event-place":"Los Angeles CA USA","event-title":"CCS '22: 2022 ACM SIGSAC Conference on Computer and Communications Security","ISBN":"978-1-4503-9450-5","issued":{"date-parts":[["2022",11,7]]},"language":"en","page":"2975-2988","publisher":"ACM","publisher-place":"Los Angeles CA USA","source":"DOI.org (Crossref)","title":"Understanding and Mitigating Remote Code Execution Vulnerabilities in Cross-platform Ecosystem","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3548606.3559340"},
  {"id":"xuGUIDERGUIStructure2021","accessed":{"date-parts":[["2023",6,4]]},"author":[{"family":"Xu","given":"Tongtong"},{"family":"Pan","given":"Minxue"},{"family":"Pei","given":"Yu"},{"family":"Li","given":"Guiyin"},{"family":"Zeng","given":"Xia"},{"family":"Zhang","given":"Tian"},{"family":"Deng","given":"Yuetang"},{"family":"Li","given":"Xuandong"}],"citation-key":"xuGUIDERGUIStructure2021","container-title":"Proceedings of the 30th ACM SIGSOFT International Symposium on Software Testing and Analysis","DOI":"10.1145/3460319.3464830","event-place":"Virtual Denmark","event-title":"ISSTA '21: 30th ACM SIGSOFT International Symposium on Software Testing and Analysis","ISBN":"978-1-4503-8459-9","issued":{"date-parts":[["2021",7,11]]},"language":"en","page":"191-203","publisher":"ACM","publisher-place":"Virtual Denmark","source":"DOI.org (Crossref)","title":"GUIDER: GUI structure and vision co-guided test script repair for Android apps","title-short":"GUIDER","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3460319.3464830"},
  {"id":"yangAutomatedGenerationEventOriented2018","abstract":"Recently more and more Android apps integrate the embedded browser, known as “WebView”, to render web pages and run JavaScript code without leaving these apps. WebView provides a powerful feature that allows event handlers deﬁned in the native context (i.e., Java in Android) to handle web events that occur in WebView. However, as shown in prior work, this feature suffers from remote attacks, which we generalize as EventOriented Exploit (EOE) in this paper, such that adversaries may remotely access local critical functionalities through event handlers in WebView without any permission or authentication. In this paper, we propose a novel approach, EOEDroid, which can automatically vet event handlers in a given hybrid app using selective symbolic execution and static analysis. If a vulnerability is found, EOEDroid also automatically generates exploit code to help developers and analysts verify the vulnerability. To support exploit code generation, we also systematically study web events, event handlers and their trigger constraints. We evaluated our approach on 3,652 most popular apps. The result showed that our approach found 97 total vulnerabilities in 58 apps, including 2 cross-frame DOM manipulation, 53 phishing, 30 sensitive information leakage, 1 local resources access, and 11 Intent abuse vulnerabilities. We also found a potential backdoor in a high proﬁle app that could be used to steal users’ sensitive information, such as IMEI. Even though developers attempted to close it, EOEDroid found that adversaries were still able to exploit it by triggering two events together and feeding event handlers with well designed input.","accessed":{"date-parts":[["2023",2,21]]},"author":[{"family":"Yang","given":"Guangliang"},{"family":"Huang","given":"Jeff"},{"family":"Gu","given":"Guofei"}],"citation-key":"yangAutomatedGenerationEventOriented2018","container-title":"Proceedings 2018 Network and Distributed System Security Symposium","DOI":"10.14722/ndss.2018.23236","event-place":"San Diego, CA","event-title":"Network and Distributed System Security Symposium","ISBN":"978-1-891562-49-5","issued":{"date-parts":[["2018"]]},"language":"en","publisher":"Internet Society","publisher-place":"San Diego, CA","source":"DOI.org (Crossref)","title":"Automated Generation of Event-Oriented Exploits in Android Hybrid Apps","type":"paper-conference","URL":"https://www.ndss-symposium.org/wp-content/uploads/2018/02/ndss2018_04B-3_Yang_paper.pdf"},
  {"id":"yangCrossMiniappRequest2022","abstract":"A miniapp is a full-fledged app that is executed inside a mobile super app such as WeChat or SnapChat. Being mini by nature, it often has to communicate with other miniapps to accomplish complicated tasks. However, unlike a web app that uses network domains (i.e., IP addresses) to navigate between different web apps, a miniapp uses a unique global appId assigned by the super app to navigate between miniapps. Unfortunately, any missing checks of the sender’s appId in a receiver miniapp can lead to a new type of attacks we name it cross-miniapp request forgery (CMRF). In addition to demystifying the root cause of this attack (i.e., the essence of the vulnerability), this paper also seeks to measure the popularity of this vulnerability among miniapps by developing CmrfScanner, which is able to statically detect the CMRF-vulnerability based on the abstract syntax tree of miniapp code to determine whether there are any missing checks of the appIds. We have tested CmrfScanner with 2,571,490 WeChat miniapps and 148,512 Baidu miniapps, and identified 52,394 (2.04%) WeChat miniapps and 494 (0.33%) Baidu miniapps that involve cross-communication. Among them, CmrfScanner further identified that 50,281 (95.97%) of WeChat miniapps, and 493 (99.80%) of Baidu miniapps lack the appID checks of the sender’s mini-apps, indicating that a large amount of miniapp developers are not aware of this attack. We also estimated the impact of this vulnerability and found 55.05% of the lack of validation WeChat miniapps (7.09% of such Baidu miniapps) can have direct security consequences such as privileged data access, information leakage, promotion abuse, and even shopping for free. We hope that our findings can raise awareness among miniapp developers, and future miniapps will not be subject to CMRF attacks.","accessed":{"date-parts":[["2022",12,27]]},"author":[{"family":"Yang","given":"Yuqing"},{"family":"Zhang","given":"Yue"},{"family":"Lin","given":"Zhiqiang"}],"citation-key":"yangCrossMiniappRequest2022","container-title":"Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security","DOI":"10.1145/3548606.3560597","event-place":"Los Angeles CA USA","event-title":"CCS '22: 2022 ACM SIGSAC Conference on Computer and Communications Security","ISBN":"978-1-4503-9450-5","issued":{"date-parts":[["2022",11,7]]},"language":"en","page":"3079-3092","publisher":"ACM","publisher-place":"Los Angeles CA USA","source":"DOI.org (Crossref)","title":"Cross Miniapp Request Forgery: Root Causes, Attacks, and Vulnerability Detection","title-short":"Cross Miniapp Request Forgery","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3548606.3560597"},
  {"id":"yangIframesPopupsAre","abstract":"In this paper, we present a novel class of Android WebView vulnerabilities (called Differential Context Vulnerabilities or DCVs) associated with web iframe/popup behaviors. To demonstrate the security implications of DCVs, we devise several novel concrete attacks. We show an untrusted web iframe/popup inside WebView becomes dangerous that it can launch these attacks to open holes on existing defense solutions, and obtain risky privileges and abilities, such as breaking web messaging integrity, stealthily accessing sensitive mobile functionalities, and performing phishing attacks. Then, we study and assess the security impacts of DCVs on real-world apps. For this purpose, we develop a novel technique, DCV-Hunter, that can automatically vet Android apps against DCVs. By applying DCV-Hunter on a large number of most popular apps, we ﬁnd DCVs are prevalent. Many highproﬁle apps are veriﬁed to be impacted, such as Facebook, Instagram, Facebook Messenger, Google News, Skype, Uber, Yelp, and U.S. Bank. To mitigate DCVs, we design a multilevel solution that enhances the security of WebView. Our evaluation on real-world apps shows the mitigation solution is effective and scalable, with negligible overhead.","author":[{"family":"Yang","given":"GuangLiang"},{"family":"Huang","given":"Jeff"},{"family":"Gu","given":"Guofei"}],"citation-key":"yangIframesPopupsAre","language":"en","source":"Zotero","title":"Iframes/Popups Are Dangerous in Mobile WebView: Studying and Mitigating Differential Context Vulnerabilities","type":"article-journal"},
  {"id":"yangPermDroidAutomaticallyTesting2022","accessed":{"date-parts":[["2023",6,4]]},"author":[{"family":"Yang","given":"Shuaihao"},{"family":"Zeng","given":"Zigang"},{"family":"Song","given":"Wei"}],"citation-key":"yangPermDroidAutomaticallyTesting2022","container-title":"Proceedings of the 31st ACM SIGSOFT International Symposium on Software Testing and Analysis","DOI":"10.1145/3533767.3534221","event-place":"Virtual South Korea","event-title":"ISSTA '22: 31st ACM SIGSOFT International Symposium on Software Testing and Analysis","ISBN":"978-1-4503-9379-9","issued":{"date-parts":[["2022",7,18]]},"language":"en","page":"593-604","publisher":"ACM","publisher-place":"Virtual South Korea","source":"DOI.org (Crossref)","title":"PermDroid: automatically testing permission-related behaviour of Android applications","title-short":"PermDroid","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3533767.3534221"},
  {"id":"yangPreciselyScalablyVetting2017","abstract":"In this paper, we propose a novel system, named BridgeScope, for precise and scalable vetting of JavaScript Bridge security issues in Android hybrid apps. BridgeScope is ﬂexible and can be leveraged to analyze a diverse set of WebView implementations, such as Android’s default WebView, and Mozilla’s Rhino-based WebView. Furthermore, BridgeScope can automatically generate test exploit code to further conﬁrm any discovered JavaScript Bridge vulnerability. We evaluated BridgeScope to demonstrate that it is precise and eﬀective in ﬁnding JavaScript Bridge vulnerabilities. On average, it can vet an app within seven seconds with a low false positive rate. A large scale evaluation identiﬁed hundreds of potentially vulnerable real-world popular apps that could lead to critical exploitation. Furthermore, we also demonstrate that BridgeScope can discover malicious functionalities that leverage JavaScript Bridge in real-world malicious apps, even when the associated malicious severs were unavailable.","accessed":{"date-parts":[["2023",2,21]]},"author":[{"family":"Yang","given":"Guangliang"},{"family":"Mendoza","given":"Abner"},{"family":"Zhang","given":"Jialong"},{"family":"Gu","given":"Guofei"}],"citation-key":"yangPreciselyScalablyVetting2017","container-title":"Research in Attacks, Intrusions, and Defenses","DOI":"10.1007/978-3-319-66332-6_7","editor":[{"family":"Dacier","given":"Marc"},{"family":"Bailey","given":"Michael"},{"family":"Polychronakis","given":"Michalis"},{"family":"Antonakakis","given":"Manos"}],"event-place":"Cham","ISBN":"978-3-319-66331-9 978-3-319-66332-6","issued":{"date-parts":[["2017"]]},"language":"en","page":"143-166","publisher":"Springer International Publishing","publisher-place":"Cham","source":"DOI.org (Crossref)","title":"Precisely and Scalably Vetting JavaScript Bridge in Android Hybrid Apps","type":"chapter","URL":"http://link.springer.com/10.1007/978-3-319-66332-6_7","volume":"10453"},
  {"id":"yangStaticWindowTransition2015","abstract":"This work develops a static analysis to create a model of the behavior of an Android application's GUI. We propose the window transition graph (WTG), a model representing the possible GUI window sequences and their associated events and callbacks. A key component and contribution of our work is the careful modeling of the stack of currently-active windows, the changes to this stack, and the effects of callbacks related to these changes. To the best of our knowledge, this is the first detailed study of this important static analysis problem for Android. We develop novel analysis algorithms for WTG construction and traversal, based on this modeling of the window stack. We also describe an application of the WTG for GUI test generation, using path traversals. The evaluation of the proposed algorithms indicates their effectiveness and practicality.","author":[{"family":"Yang","given":"Shengqian"},{"family":"Zhang","given":"Hailong"},{"family":"Wu","given":"Haowei"},{"family":"Wang","given":"Yan"},{"family":"Yan","given":"Dacong"},{"family":"Rountev","given":"Atanas"}],"citation-key":"yangStaticWindowTransition2015","container-title":"2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE)","DOI":"10.1109/ASE.2015.76","event-title":"2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE)","issued":{"date-parts":[["2015",1]]},"page":"658-668","source":"IEEE Xplore","title":"Static Window Transition Graphs for Android (T)","type":"paper-conference"},
  {"id":"yangStudyMitigationOrigin2018","accessed":{"date-parts":[["2023",2,21]]},"author":[{"family":"Yang","given":"Guangliang"},{"family":"Huang","given":"Jeff"},{"family":"Gu","given":"Guofei"},{"family":"Mendoza","given":"Abner"}],"citation-key":"yangStudyMitigationOrigin2018","container-title":"2018 IEEE Symposium on Security and Privacy (SP)","DOI":"10.1109/SP.2018.00043","event-place":"San Francisco, CA","event-title":"2018 IEEE Symposium on Security and Privacy (SP)","ISBN":"978-1-5386-4353-2","issued":{"date-parts":[["2018",5]]},"language":"en","page":"742-755","publisher":"IEEE","publisher-place":"San Francisco, CA","source":"DOI.org (Crossref)","title":"Study and Mitigation of Origin Stripping Vulnerabilities in Hybrid-postMessage Enabled Mobile Applications","type":"paper-conference","URL":"https://ieeexplore.ieee.org/document/8418635/"},
  {"id":"yanMUIDDetectingSensitive2023","abstract":"In recent years, the rise of miniapps, lightweight applications based on WebView, has become a prominent trend in mobile app development. This trend has rapidly expanded on popular social platforms like WeChat, TikTok, Grab, and even Snapchat. In these miniapps, user data is pivotal for providing personalized services and improving user experience. However, there are still shortcomings in identifying the source of sensitive data in miniapps. This paper introduces MUID, an innovative method for detecting user input data in miniapps. MUID integrates an engine that can dynamically test miniapps to overcome the challenges in WebView page extraction, uses a hybrid analysis approach to identify sensitive components, and infers the type of information collected based on contextual hint words. In the evaluation of MUID across 30 popular miniapps randomly selected on WeChat, we demonstrated its high dynamic testing efficiency and its capability to recognize components with a recall rate of 95.74% and a precision rate of 81.32%. The overall precision of MUID is 78.31%, and the recall rate is 92.19%, demonstrating the effectiveness of MUID in conducting security and privacy analyses.","accessed":{"date-parts":[["2023",12,13]]},"author":[{"family":"Yan","given":"Ziqiang"},{"family":"Fan","given":"Ming"},{"family":"Wang","given":"Yin"},{"family":"Shi","given":"Jifei"},{"family":"Wang","given":"Haoran"},{"family":"Liu","given":"Ting"}],"citation-key":"yanMUIDDetectingSensitive2023","container-title":"Proceedings of the 2023 ACM Workshop on Secure and Trustworthy Superapps","DOI":"10.1145/3605762.3624429","event-place":"Copenhagen Denmark","event-title":"CCS '23: ACM SIGSAC Conference on Computer and Communications Security","ISBN":"9798400702587","issued":{"date-parts":[["2023",11,26]]},"language":"en","page":"17-21","publisher":"ACM","publisher-place":"Copenhagen Denmark","source":"DOI.org (Crossref)","title":"MUID: Detecting Sensitive User Inputs in Miniapp Ecosystems","title-short":"MUID","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3605762.3624429"},
  {"id":"yanMultipleentryTestingAndroid2020","accessed":{"date-parts":[["2023",6,2]]},"author":[{"family":"Yan","given":"Jiwei"},{"family":"Liu","given":"Hao"},{"family":"Pan","given":"Linjie"},{"family":"Yan","given":"Jun"},{"family":"Zhang","given":"Jian"},{"family":"Liang","given":"Bin"}],"citation-key":"yanMultipleentryTestingAndroid2020","container-title":"Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering","DOI":"10.1145/3377811.3380347","event-place":"Seoul South Korea","event-title":"ICSE '20: 42nd International Conference on Software Engineering","ISBN":"978-1-4503-7121-6","issued":{"date-parts":[["2020",6,27]]},"language":"en","page":"457-468","publisher":"ACM","publisher-place":"Seoul South Korea","source":"DOI.org (Crossref)","title":"Multiple-entry testing of Android applications by constructing activity launching contexts","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/3377811.3380347"},
  {"id":"zengAutomatedTestInput2016","abstract":"Given the ever increasing number of research tools to automatically generate inputs to test Android applications (or simply apps), researchers recently asked the question \"Are we there yet?\" (in terms of the practicality of the tools). By conducting an empirical study of the various tools, the researchers found that Monkey (the most widely used tool of this category in industrial practices) outperformed all of the research tools that they studied. In this paper, we present two significant extensions of that study. First, we conduct the first industrial case study of applying Monkey against WeChat, a popular messenger app with over 762 million monthly active users, and report the empirical findings on Monkey's limitations in an industrial setting. Second, we develop a new approach to address major limitations of Monkey and accomplish substantial code-coverage improvements over Monkey, along with empirical insights for future enhancements to both Monkey and our approach.","accessed":{"date-parts":[["2023",6,2]]},"author":[{"family":"Zeng","given":"Xia"},{"family":"Li","given":"Dengfeng"},{"family":"Zheng","given":"Wujie"},{"family":"Xia","given":"Fan"},{"family":"Deng","given":"Yuetang"},{"family":"Lam","given":"Wing"},{"family":"Yang","given":"Wei"},{"family":"Xie","given":"Tao"}],"citation-key":"zengAutomatedTestInput2016","collection-title":"FSE 2016","container-title":"Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering","DOI":"10.1145/2950290.2983958","event-place":"New York, NY, USA","ISBN":"978-1-4503-4218-6","issued":{"literal":"11 月 1, 2016"},"page":"987–992","publisher":"Association for Computing Machinery","publisher-place":"New York, NY, USA","source":"ACM Digital Library","title":"Automated test input generation for Android: are we really there yet in an industrial case?","title-short":"Automated test input generation for Android","type":"paper-conference","URL":"https://dl.acm.org/doi/10.1145/2950290.2983958"},
  {"id":"zhaHazardIntegratedUnderstanding2022","abstract":"Team Chat (TACT) systems are now widely used for online collaborations and project management. A unique feature of these systems is their integration of third-party apps, which extends their capabilities but also brings in the complexity that could potentially put the TACT system and its end-users at risk. In this paper, for the first time, we demonstrate that thirdparty apps in TACT systems indeed open the door to new security risks, such as privilege escalation, deception, and privacy leakage. We studied 12 popular TACT systems, following the key steps of a third-party app’s life cycle (its installation, update, configuration, and runtime operations). Notably, we designed and implemented a pipeline for efficiently identifying the security risks of TA APIs, a core feature provided for system-app communication.","accessed":{"date-parts":[["2022",12,27]]},"author":[{"family":"Zha","given":"Mingming"},{"family":"Wang","given":"Jice"},{"family":"Nan","given":"Yuhong"},{"family":"Wang","given":"Xiaofeng"},{"family":"Zhang","given":"Yuqing"},{"family":"Yang","given":"Zelin"}],"citation-key":"zhaHazardIntegratedUnderstanding2022","container-title":"Proceedings 2022 Network and Distributed System Security Symposium","DOI":"10.14722/ndss.2022.24387","event-place":"San Diego, CA, USA","event-title":"Network and Distributed System Security Symposium","ISBN":"978-1-891562-74-7","issued":{"date-parts":[["2022"]]},"language":"en","publisher":"Internet Society","publisher-place":"San Diego, CA, USA","source":"DOI.org (Crossref)","title":"Hazard Integrated: Understanding Security Risks in App Extensions to Team Chat Systems","title-short":"Hazard Integrated","type":"paper-conference","URL":"https://www.ndss-symposium.org/wp-content/uploads/2022-387-paper.pdf"},
  {"id":"zhangEmpiricalStudyWeb","abstract":"Mobile apps have become the main channel for accessing Web services. Both Android and iOS feature inapp Web browsers that support convenient Web service integration through a set of Web resource manipulation APIs. Previous work have revealed the attack surfaces of Web resource manipulation APIs and proposed several defense mechanisms. However, none of them provides evidence that such attacks indeed happen in the real world, measures their impacts, and evaluates the proposed defensive techniques against real attacks.","author":[{"family":"Zhang","given":"Xiaohan"},{"family":"Zhang","given":"Yuan"},{"family":"Mo","given":"Qianqian"},{"family":"Xia","given":"Hao"},{"family":"Yang","given":"Zhemin"},{"family":"Yang","given":"Min"},{"family":"Wang","given":"Xiaofeng"},{"family":"Lu","given":"Long"},{"family":"Duan","given":"Haixin"}],"citation-key":"zhangEmpiricalStudyWeb","language":"en","source":"Zotero","title":"An Empirical Study of Web Resource Manipulation in Real-world Mobile Applications","type":"article-journal"},
  {"id":"zhangIdentityConfusionWebViewbased","abstract":"Mobile applications (apps) often delegate their own functions to other parties, which makes them become a super ecosystem hosting these parties. Therefore, such mobile apps are being called super-apps, and the delegated parties are subsequently called sub-apps, behaving like “app-in-app”. Sub-apps not only load (third-party) resources like a normal app, but also have access to the privileged APIs provided by the super-app. This leads to an important research question—determining who can access these privileged APIs. Real-world super-apps, according to our study, adopt three types of identities—namely web domains, sub-app IDs, and capabilities—to determine privileged API access. However, existing identity checks of these three types are often not well designed, leading to a disobey of the least privilege principle. That is, the granted recipient of a privileged API is broader than intended, thus defined as an “identity confusion” in this paper. To the best of our knowledge, no prior works have studied this type of identity confusion vulnerability.","author":[{"family":"Zhang","given":"Lei"},{"family":"Zhang","given":"Zhibo"},{"family":"Liu","given":"Ancong"},{"family":"Cao","given":"Yinzhi"},{"family":"Zhang","given":"Xiaohan"},{"family":"Chen","given":"Yanjun"},{"family":"Zhang","given":"Yuan"},{"family":"Yang","given":"Guangliang"},{"family":"Yang","given":"Min"}],"citation-key":"zhangIdentityConfusionWebViewbased","language":"en","source":"Zotero","title":"Identity Confusion in WebView-based Mobile App-in-app Ecosystems","type":"article-journal"},
  {"id":"zhaoGeolocatingDriversStudy2019","abstract":"Increasingly, mobile application-based ride-hailing services have become a very popular means of transportation. Due to the handling of business logic, these services also contain a wealth of privacy-sensitive information such as GPS locations, car plates, driver licenses, and payment data. Unlike many of the mobile applications in which there is only one type of users, ride-hailing services face two types of users: riders and drivers. While most of the efforts had focused on the rider’s privacy, unfortunately, we notice little has been done to protect drivers. To raise the awareness of the privacy issues with drivers, in this paper we perform the ﬁrst systematic study of the drivers’ sensitive data leakage in ride-hailing services. More speciﬁcally, we select 20 popular ride-hailing apps including Uber and Lyft and focus on one particular feature, namely the nearby cars feature. Surprisingly, our experimental results show that largescale data harvesting of drivers is possible for all of the ridehailing services we studied. In particular, attackers can determine with high-precision the driver’s privacy-sensitive information including mostly visited address (e.g., home) and daily driving behaviors. Meanwhile, attackers can also infer sensitive information about the business operations and performances of ride-hailing services such as the number of rides, utilization of cars, and presence on the territory. In addition to presenting the attacks, we also shed light on the countermeasures the service providers could take to protect the driver’s sensitive information.","accessed":{"date-parts":[["2022",12,27]]},"author":[{"family":"Zhao","given":"Qingchuan"},{"family":"Zuo","given":"Chaoshun"},{"family":"Pellegrino","given":"Giancarlo"},{"family":"Lin","given":"Zhiqiang"}],"citation-key":"zhaoGeolocatingDriversStudy2019","container-title":"Proceedings 2019 Network and Distributed System Security Symposium","DOI":"10.14722/ndss.2019.23052","event-place":"San Diego, CA","event-title":"Network and Distributed System Security Symposium","ISBN":"978-1-891562-55-6","issued":{"date-parts":[["2019"]]},"language":"en","publisher":"Internet Society","publisher-place":"San Diego, CA","source":"DOI.org (Crossref)","title":"Geo-locating Drivers: A Study of Sensitive Data Leakage in Ride-Hailing Services","title-short":"Geo-locating Drivers","type":"paper-conference","URL":"https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_01A-5_Zhao_paper.pdf"},
  {"id":"zuoWhyDoesYour2019","abstract":"Increasingly, more and more mobile applications (apps for short) are using the cloud as the back-end, in particular the cloud APIs, for data storage, data analytics, message notiﬁcation, and monitoring. Unfortunately, we have recently witnessed massive data leaks from the cloud, ranging from personally identiﬁable information to corporate secrets. In this paper, we seek to understand why such signiﬁcant leaks occur and design tools to automatically identify them. To our surprise, our study reveals that lack of authentication, misuse of various keys (e.g., normal user keys and superuser keys) in authentication, or misconﬁguration of user permissions in authorization are the root causes. Then, we design a set of automated program analysis techniques including obfuscation-resilient cloud API identiﬁcation and string value analysis, and implement them in a tool called LeakScope to identify the potential data leakage vulnerabilities from mobile apps based on how the cloud APIs are used. Our evaluation with over 1.6 million mobile apps from the Google Play Store has uncovered 15, 098 app servers managed by mainstream cloud providers such as Amazon, Google, and Microsoft that are subject to data leakage attacks. We have made responsible disclosure to each of the cloud service providers, and they have all conﬁrmed the vulnerabilities we have identiﬁed and are actively working with the mobile app developers to patch their vulnerable services.","accessed":{"date-parts":[["2022",12,27]]},"author":[{"family":"Zuo","given":"Chaoshun"},{"family":"Lin","given":"Zhiqiang"},{"family":"Zhang","given":"Yinqian"}],"citation-key":"zuoWhyDoesYour2019","container-title":"2019 IEEE Symposium on Security and Privacy (SP)","DOI":"10.1109/SP.2019.00009","event-place":"San Francisco, CA, USA","event-title":"2019 IEEE Symposium on Security and Privacy (SP)","ISBN":"978-1-5386-6660-9","issued":{"date-parts":[["2019",5]]},"language":"en","page":"1296-1310","publisher":"IEEE","publisher-place":"San Francisco, CA, USA","source":"DOI.org (Crossref)","title":"Why Does Your Data Leak? Uncovering the Data Leakage in Cloud from Mobile Apps","title-short":"Why Does Your Data Leak?","type":"paper-conference","URL":"https://ieeexplore.ieee.org/document/8835301/"}
]
